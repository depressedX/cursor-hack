define(de[307], he([1, 0, 4, 97, 51, 35]), function (ce, e, t, i, w, E) {
			"use strict";
			Object.defineProperty(e, "__esModule", { value: !0 }),
				(e.$tU =
					e.$sU =
					e.$rU =
					e.$qU =
					e.$pU =
					e.$oU =
					e.$nU =
					e.$mU =
					e.$lU =
					e.$kU =
					e.$jU =
					e.$iU =
					e.$hU =
					e.$gU =
					e.$fU =
					e.$eU =
					e.$dU =
					e.$cU =
					e.$bU =
					e.$aU =
					e.$_T =
					e.$$T =
					e.$0T =
					e.$9T =
					e.$8T =
					e.$7T =
					e.$6T =
					e.$5T =
					e.$4T =
					e.$3T =
					e.$2T =
					e.$1T =
					e.$ZT =
					e.$YT =
					e.$XT =
					e.$WT =
					e.$VT =
					e.$UT =
					e.$TT =
					e.$ST =
					e.$RT =
					e.$QT =
					e.$PT =
					e.$OT =
					e.$NT =
					e.$MT =
					e.$LT =
					e.$KT =
					e.$JT =
					e.$IT =
					e.$HT =
					e.$GT =
					e.$FT =
					e.$ET =
					e.$DT =
					e.$CT =
					e.$BT =
					e.$AT =
					e.$zT =
					e.$yT =
					e.$xT =
					e.$wT =
					e.$vT =
					e.$uT =
					e.$tT =
					e.$sT =
					e.$rT =
						void 0),
				(t = mt(t)),
				(e.$rT = (0, w.$wP)(
					"editor.lineHighlightBackground",
					null,
					t.localize(670, null),
				)),
				(e.$sT = (0, w.$wP)(
					"editor.lineHighlightBorder",
					{
						dark: "#282828",
						light: "#eeeeee",
						hcDark: "#f38518",
						hcLight: w.$OP,
					},
					t.localize(671, null),
				)),
				(e.$tT = (0, w.$wP)(
					"editor.rangeHighlightBackground",
					{
						dark: "#ffffff0b",
						light: "#fdff0033",
						hcDark: null,
						hcLight: null,
					},
					t.localize(672, null),
					!0,
				)),
				(e.$uT = (0, w.$wP)(
					"editor.rangeHighlightBorder",
					{ dark: null, light: null, hcDark: w.$PP, hcLight: w.$PP },
					t.localize(673, null),
				)),
				(e.$vT = (0, w.$wP)(
					"editor.symbolHighlightBackground",
					{ dark: w.$yQ, light: w.$yQ, hcDark: null, hcLight: null },
					t.localize(674, null),
					!0,
				)),
				(e.$wT = (0, w.$wP)(
					"editor.symbolHighlightBorder",
					{ dark: null, light: null, hcDark: w.$PP, hcLight: w.$PP },
					t.localize(675, null),
				)),
				(e.$xT = (0, w.$wP)(
					"editorCursor.foreground",
					{
						dark: "#AEAFAD",
						light: i.$UL.black,
						hcDark: i.$UL.white,
						hcLight: "#0F4A85",
					},
					t.localize(676, null),
				)),
				(e.$yT = (0, w.$wP)(
					"editorCursor.background",
					null,
					t.localize(677, null),
				)),
				(e.$zT = (0, w.$wP)(
					"editorMultiCursor.primary.foreground",
					e.$xT,
					t.localize(678, null),
				)),
				(e.$AT = (0, w.$wP)(
					"editorMultiCursor.primary.background",
					e.$yT,
					t.localize(679, null),
				)),
				(e.$BT = (0, w.$wP)(
					"editorMultiCursor.secondary.foreground",
					e.$xT,
					t.localize(680, null),
				)),
				(e.$CT = (0, w.$wP)(
					"editorMultiCursor.secondary.background",
					e.$yT,
					t.localize(681, null),
				)),
				(e.$DT = (0, w.$wP)(
					"editorWhitespace.foreground",
					{
						dark: "#e3e4e229",
						light: "#33333333",
						hcDark: "#e3e4e229",
						hcLight: "#CCCCCC",
					},
					t.localize(682, null),
				)),
				(e.$ET = (0, w.$wP)(
					"editorLineNumber.foreground",
					{
						dark: "#858585",
						light: "#237893",
						hcDark: i.$UL.white,
						hcLight: "#292929",
					},
					t.localize(683, null),
				)),
				(e.$FT = (0, w.$wP)(
					"editorIndentGuide.background",
					e.$DT,
					t.localize(684, null),
					!1,
					t.localize(685, null),
				)),
				(e.$GT = (0, w.$wP)(
					"editorIndentGuide.activeBackground",
					e.$DT,
					t.localize(686, null),
					!1,
					t.localize(687, null),
				)),
				(e.$HT = (0, w.$wP)(
					"editorIndentGuide.background1",
					e.$FT,
					t.localize(688, null),
				)),
				(e.$IT = (0, w.$wP)(
					"editorIndentGuide.background2",
					"#00000000",
					t.localize(689, null),
				)),
				(e.$JT = (0, w.$wP)(
					"editorIndentGuide.background3",
					"#00000000",
					t.localize(690, null),
				)),
				(e.$KT = (0, w.$wP)(
					"editorIndentGuide.background4",
					"#00000000",
					t.localize(691, null),
				)),
				(e.$LT = (0, w.$wP)(
					"editorIndentGuide.background5",
					"#00000000",
					t.localize(692, null),
				)),
				(e.$MT = (0, w.$wP)(
					"editorIndentGuide.background6",
					"#00000000",
					t.localize(693, null),
				)),
				(e.$NT = (0, w.$wP)(
					"editorIndentGuide.activeBackground1",
					e.$GT,
					t.localize(694, null),
				)),
				(e.$OT = (0, w.$wP)(
					"editorIndentGuide.activeBackground2",
					"#00000000",
					t.localize(695, null),
				)),
				(e.$PT = (0, w.$wP)(
					"editorIndentGuide.activeBackground3",
					"#00000000",
					t.localize(696, null),
				)),
				(e.$QT = (0, w.$wP)(
					"editorIndentGuide.activeBackground4",
					"#00000000",
					t.localize(697, null),
				)),
				(e.$RT = (0, w.$wP)(
					"editorIndentGuide.activeBackground5",
					"#00000000",
					t.localize(698, null),
				)),
				(e.$ST = (0, w.$wP)(
					"editorIndentGuide.activeBackground6",
					"#00000000",
					t.localize(699, null),
				));
			const C = (0, w.$wP)(
				"editorActiveLineNumber.foreground",
				{ dark: "#c6c6c6", light: "#0B216F", hcDark: w.$PP, hcLight: w.$PP },
				t.localize(700, null),
				!1,
				t.localize(701, null),
			);
			(e.$TT = (0, w.$wP)(
				"editorLineNumber.activeForeground",
				C,
				t.localize(702, null),
			)),
				(e.$UT = (0, w.$wP)(
					"editorLineNumber.dimmedForeground",
					null,
					t.localize(703, null),
				)),
				(e.$VT = (0, w.$wP)(
					"editorRuler.foreground",
					{
						dark: "#5A5A5A",
						light: i.$UL.lightgrey,
						hcDark: i.$UL.white,
						hcLight: "#292929",
					},
					t.localize(704, null),
				)),
				(e.$WT = (0, w.$wP)(
					"editorCodeLens.foreground",
					{
						dark: "#999999",
						light: "#919191",
						hcDark: "#999999",
						hcLight: "#292929",
					},
					t.localize(705, null),
				)),
				(e.$XT = (0, w.$wP)(
					"editorBracketMatch.background",
					{
						dark: "#0064001a",
						light: "#0064001a",
						hcDark: "#0064001a",
						hcLight: "#0000",
					},
					t.localize(706, null),
				)),
				(e.$YT = (0, w.$wP)(
					"editorBracketMatch.border",
					{ dark: "#888", light: "#B9B9B9", hcDark: w.$OP, hcLight: w.$OP },
					t.localize(707, null),
				)),
				(e.$ZT = (0, w.$wP)(
					"editorOverviewRuler.border",
					{
						dark: "#7f7f7f4d",
						light: "#7f7f7f4d",
						hcDark: "#7f7f7f4d",
						hcLight: "#666666",
					},
					t.localize(708, null),
				)),
				(e.$1T = (0, w.$wP)(
					"editorOverviewRuler.background",
					null,
					t.localize(709, null),
				)),
				(e.$2T = (0, w.$wP)(
					"editorGutter.background",
					w.$8P,
					t.localize(710, null),
				)),
				(e.$3T = (0, w.$wP)(
					"editorUnnecessaryCode.border",
					{
						dark: null,
						light: null,
						hcDark: i.$UL.fromHex("#fff").transparent(0.8),
						hcLight: w.$OP,
					},
					t.localize(711, null),
				)),
				(e.$4T = (0, w.$wP)(
					"editorUnnecessaryCode.opacity",
					{
						dark: i.$UL.fromHex("#000a"),
						light: i.$UL.fromHex("#0007"),
						hcDark: null,
						hcLight: null,
					},
					t.localize(712, null),
				)),
				(e.$5T = (0, w.$wP)(
					"editorGhostText.border",
					{
						dark: null,
						light: null,
						hcDark: i.$UL.fromHex("#fff").transparent(0.8),
						hcLight: i.$UL.fromHex("#292929").transparent(0.8),
					},
					t.localize(713, null),
				)),
				(e.$6T = (0, w.$wP)(
					"editorGhostText.foreground",
					{
						dark: i.$UL.fromHex("#ffffff56"),
						light: i.$UL.fromHex("#0007"),
						hcDark: null,
						hcLight: null,
					},
					t.localize(714, null),
				)),
				(e.$7T = (0, w.$wP)(
					"editorGhostText.background",
					null,
					t.localize(715, null),
				));
			const d = new i.$UL(new i.$RL(0, 122, 204, 0.6));
			(e.$8T = (0, w.$wP)(
				"editorOverviewRuler.rangeHighlightForeground",
				d,
				t.localize(716, null),
				!0,
			)),
				(e.$9T = (0, w.$wP)(
					"editorOverviewRuler.errorForeground",
					{
						dark: new i.$UL(new i.$RL(255, 18, 18, 0.7)),
						light: new i.$UL(new i.$RL(255, 18, 18, 0.7)),
						hcDark: new i.$UL(new i.$RL(255, 50, 50, 1)),
						hcLight: "#B5200D",
					},
					t.localize(717, null),
				)),
				(e.$0T = (0, w.$wP)(
					"editorOverviewRuler.warningForeground",
					{ dark: w.$jQ, light: w.$jQ, hcDark: w.$kQ, hcLight: w.$kQ },
					t.localize(718, null),
				)),
				(e.$$T = (0, w.$wP)(
					"editorOverviewRuler.infoForeground",
					{ dark: w.$mQ, light: w.$mQ, hcDark: w.$nQ, hcLight: w.$nQ },
					t.localize(719, null),
				)),
				(e.$_T = (0, w.$wP)(
					"editorBracketHighlight.foreground1",
					{
						dark: "#FFD700",
						light: "#0431FAFF",
						hcDark: "#FFD700",
						hcLight: "#0431FAFF",
					},
					t.localize(720, null),
				)),
				(e.$aU = (0, w.$wP)(
					"editorBracketHighlight.foreground2",
					{
						dark: "#DA70D6",
						light: "#319331FF",
						hcDark: "#DA70D6",
						hcLight: "#319331FF",
					},
					t.localize(721, null),
				)),
				(e.$bU = (0, w.$wP)(
					"editorBracketHighlight.foreground3",
					{
						dark: "#179FFF",
						light: "#7B3814FF",
						hcDark: "#87CEFA",
						hcLight: "#7B3814FF",
					},
					t.localize(722, null),
				)),
				(e.$cU = (0, w.$wP)(
					"editorBracketHighlight.foreground4",
					"#00000000",
					t.localize(723, null),
				)),
				(e.$dU = (0, w.$wP)(
					"editorBracketHighlight.foreground5",
					"#00000000",
					t.localize(724, null),
				)),
				(e.$eU = (0, w.$wP)(
					"editorBracketHighlight.foreground6",
					"#00000000",
					t.localize(725, null),
				)),
				(e.$fU = (0, w.$wP)(
					"editorBracketHighlight.unexpectedBracket.foreground",
					{
						dark: new i.$UL(new i.$RL(255, 18, 18, 0.8)),
						light: new i.$UL(new i.$RL(255, 18, 18, 0.8)),
						hcDark: "new Color(new RGBA(255, 50, 50, 1))",
						hcLight: "#B5200D",
					},
					t.localize(726, null),
				)),
				(e.$gU = (0, w.$wP)(
					"editorBracketPairGuide.background1",
					"#00000000",
					t.localize(727, null),
				)),
				(e.$hU = (0, w.$wP)(
					"editorBracketPairGuide.background2",
					"#00000000",
					t.localize(728, null),
				)),
				(e.$iU = (0, w.$wP)(
					"editorBracketPairGuide.background3",
					"#00000000",
					t.localize(729, null),
				)),
				(e.$jU = (0, w.$wP)(
					"editorBracketPairGuide.background4",
					"#00000000",
					t.localize(730, null),
				)),
				(e.$kU = (0, w.$wP)(
					"editorBracketPairGuide.background5",
					"#00000000",
					t.localize(731, null),
				)),
				(e.$lU = (0, w.$wP)(
					"editorBracketPairGuide.background6",
					"#00000000",
					t.localize(732, null),
				)),
				(e.$mU = (0, w.$wP)(
					"editorBracketPairGuide.activeBackground1",
					"#00000000",
					t.localize(733, null),
				)),
				(e.$nU = (0, w.$wP)(
					"editorBracketPairGuide.activeBackground2",
					"#00000000",
					t.localize(734, null),
				)),
				(e.$oU = (0, w.$wP)(
					"editorBracketPairGuide.activeBackground3",
					"#00000000",
					t.localize(735, null),
				)),
				(e.$pU = (0, w.$wP)(
					"editorBracketPairGuide.activeBackground4",
					"#00000000",
					t.localize(736, null),
				)),
				(e.$qU = (0, w.$wP)(
					"editorBracketPairGuide.activeBackground5",
					"#00000000",
					t.localize(737, null),
				)),
				(e.$rU = (0, w.$wP)(
					"editorBracketPairGuide.activeBackground6",
					"#00000000",
					t.localize(738, null),
				)),
				(e.$sU = (0, w.$wP)(
					"editorUnicodeHighlight.border",
					w.$jQ,
					t.localize(739, null),
				)),
				(e.$tU = (0, w.$wP)(
					"editorUnicodeHighlight.background",
					w.$iQ,
					t.localize(740, null),
				)),
				(0, E.$oP)((m, r) => {
					const u = m.getColor(w.$8P),
						a = m.getColor(e.$rT),
						h = a && !a.isTransparent() ? a : u;
					h &&
						r.addRule(
							`.monaco-editor .inputarea.ime-input { background-color: ${h}; }`,
						);
				});
		}),
		define(
			de[2847],
			he([1, 0, 591, 307, 24, 35, 104, 38, 212, 48, 2263]),
			function (ce, e, t, i, w, E, C, d, m, r) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$lvb = e.$kvb = e.$jvb = void 0),
					(w = mt(w));
				class u extends t.$_ub {
					constructor(n) {
						super(), (this.c = n);
						const g = this.c.configuration.options,
							p = g.get(d.EditorOption.layoutInfo);
						(this.g = g.get(d.EditorOption.renderLineHighlight)),
							(this.r = g.get(d.EditorOption.renderLineHighlightOnlyWhenFocus)),
							(this.j = p.isViewportWrapping),
							(this.m = p.contentLeft),
							(this.n = p.contentWidth),
							(this.q = !0),
							(this.t = !1),
							(this.u = [1]),
							(this.w = [new C.$kL(1, 1, 1, 1)]),
							(this.y = null),
							this.c.addEventHandler(this);
					}
					dispose() {
						this.c.removeEventHandler(this), super.dispose();
					}
					z() {
						let n = !1;
						const g = new Set();
						for (const f of this.w) g.add(f.positionLineNumber);
						const p = Array.from(g);
						p.sort((f, b) => f - b),
							w.$yb(this.u, p) || ((this.u = p), (n = !0));
						const o = this.w.every((f) => f.isEmpty());
						return this.q !== o && ((this.q = o), (n = !0)), n;
					}
					onThemeChanged(n) {
						return this.z();
					}
					onConfigurationChanged(n) {
						const g = this.c.configuration.options,
							p = g.get(d.EditorOption.layoutInfo);
						return (
							(this.g = g.get(d.EditorOption.renderLineHighlight)),
							(this.r = g.get(d.EditorOption.renderLineHighlightOnlyWhenFocus)),
							(this.j = p.isViewportWrapping),
							(this.m = p.contentLeft),
							(this.n = p.contentWidth),
							!0
						);
					}
					onCursorStateChanged(n) {
						return (this.w = n.selections), this.z();
					}
					onFlushed(n) {
						return !0;
					}
					onLinesDeleted(n) {
						return !0;
					}
					onLinesInserted(n) {
						return !0;
					}
					onScrollChanged(n) {
						return n.scrollWidthChanged || n.scrollTopChanged;
					}
					onZonesChanged(n) {
						return !0;
					}
					onFocusChanged(n) {
						return this.r ? ((this.t = n.isFocused), !0) : !1;
					}
					prepareRender(n) {
						if (!this.G()) {
							this.y = null;
							return;
						}
						const g = n.visibleRange.startLineNumber,
							p = n.visibleRange.endLineNumber,
							o = [];
						for (let b = g; b <= p; b++) {
							const s = b - g;
							o[s] = "";
						}
						if (this.j) {
							const b = this.I(n, !1);
							for (const s of this.u) {
								const l = this.c.viewModel.coordinatesConverter,
									y = l.convertViewPositionToModelPosition(
										new r.$hL(s, 1),
									).lineNumber,
									$ = l.convertModelPositionToViewPosition(
										new r.$hL(y, 1),
									).lineNumber,
									v = l.convertModelPositionToViewPosition(
										new r.$hL(y, this.c.viewModel.model.getLineMaxColumn(y)),
									).lineNumber,
									S = Math.max($, g),
									I = Math.min(v, p);
								for (let T = S; T <= I; T++) {
									const P = T - g;
									o[P] = b;
								}
							}
						}
						const f = this.I(n, !0);
						for (const b of this.u) {
							if (b < g || b > p) continue;
							const s = b - g;
							o[s] = f;
						}
						this.y = o;
					}
					render(n, g) {
						if (!this.y) return "";
						const p = g - n;
						return p >= this.y.length ? "" : this.y[p];
					}
					C() {
						return (
							(this.g === "gutter" || this.g === "all") && (!this.r || this.t)
						);
					}
					F() {
						return (
							(this.g === "line" || this.g === "all") &&
							this.q &&
							(!this.r || this.t)
						);
					}
				}
				e.$jvb = u;
				class a extends u {
					I(n, g) {
						return `<div class="${"current-line" + (this.C() ? " current-line-both" : "") + (g ? " current-line-exact" : "")}" style="width:${Math.max(n.scrollWidth, this.n)}px;"></div>`;
					}
					G() {
						return this.F();
					}
					H() {
						return this.C();
					}
				}
				e.$kvb = a;
				class h extends u {
					I(n, g) {
						return `<div class="${"current-line" + (this.C() ? " current-line-margin" : "") + (this.H() ? " current-line-margin-both" : "") + (this.C() && g ? " current-line-exact-margin" : "")}" style="width:${this.m}px"></div>`;
					}
					G() {
						return !0;
					}
					H() {
						return this.F();
					}
				}
				(e.$lvb = h),
					(0, E.$oP)((c, n) => {
						const g = c.getColor(i.$rT);
						if (
							(g &&
								(n.addRule(
									`.monaco-editor .view-overlays .current-line { background-color: ${g}; }`,
								),
								n.addRule(
									`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${g}; border: none; }`,
								)),
							!g || g.isTransparent() || c.defines(i.$sT))
						) {
							const p = c.getColor(i.$sT);
							p &&
								(n.addRule(
									`.monaco-editor .view-overlays .current-line-exact { border: 2px solid ${p}; }`,
								),
								n.addRule(
									`.monaco-editor .margin-view-overlays .current-line-exact-margin { border: 2px solid ${p}; }`,
								),
								(0, m.$gP)(c.type) &&
									(n.addRule(
										".monaco-editor .view-overlays .current-line-exact { border-width: 1px; }",
									),
									n.addRule(
										".monaco-editor .margin-view-overlays .current-line-exact-margin { border-width: 1px; }",
									)));
						}
					});
			},
		),
		define(
			de[2848],
			he([1, 0, 591, 307, 35, 38, 48, 24, 28, 1543, 1150, 2266]),
			function (ce, e, t, i, w, E, C, d, m, r, u) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$tvb = void 0);
				class a extends t.$_ub {
					constructor(n) {
						super(), (this.a = n), (this.b = null);
						const g = this.a.configuration.options,
							p = g.get(E.EditorOption.wrappingInfo),
							o = g.get(E.EditorOption.fontInfo);
						(this.j = o.spaceWidth),
							(this.n =
								p.wrappingColumn === -1
									? -1
									: p.wrappingColumn * o.typicalHalfwidthCharacterWidth),
							(this.q = g.get(E.EditorOption.guides)),
							(this.m = null),
							this.a.addEventHandler(this);
					}
					dispose() {
						this.a.removeEventHandler(this), (this.m = null), super.dispose();
					}
					onConfigurationChanged(n) {
						const g = this.a.configuration.options,
							p = g.get(E.EditorOption.wrappingInfo),
							o = g.get(E.EditorOption.fontInfo);
						return (
							(this.j = o.spaceWidth),
							(this.n =
								p.wrappingColumn === -1
									? -1
									: p.wrappingColumn * o.typicalHalfwidthCharacterWidth),
							(this.q = g.get(E.EditorOption.guides)),
							!0
						);
					}
					onCursorStateChanged(n) {
						const p = n.selections[0].getPosition();
						return this.b?.equals(p) ? !1 : ((this.b = p), !0);
					}
					onDecorationsChanged(n) {
						return !0;
					}
					onFlushed(n) {
						return !0;
					}
					onLinesChanged(n) {
						return !0;
					}
					onLinesDeleted(n) {
						return !0;
					}
					onLinesInserted(n) {
						return !0;
					}
					onScrollChanged(n) {
						return n.scrollTopChanged;
					}
					onZonesChanged(n) {
						return !0;
					}
					onLanguageConfigurationChanged(n) {
						return !0;
					}
					prepareRender(n) {
						if (!this.q.indentation && this.q.bracketPairs === !1) {
							this.m = null;
							return;
						}
						const g = n.visibleRange.startLineNumber,
							p = n.visibleRange.endLineNumber,
							o = n.scrollWidth,
							f = this.b,
							b = this.r(
								g,
								Math.min(p + 1, this.a.viewModel.getLineCount()),
								f,
							),
							s = [];
						for (let l = g; l <= p; l++) {
							const y = l - g,
								$ = b[y];
							let v = "";
							const S = n.visibleRangeForPosition(new C.$hL(l, 1))?.left ?? 0;
							for (const I of $) {
								const T =
									I.column === -1
										? S + (I.visibleColumn - 1) * this.j
										: n.visibleRangeForPosition(new C.$hL(l, I.column)).left;
								if (T > o || (this.n > 0 && T > this.n)) break;
								const P = I.horizontalLine
										? I.horizontalLine.top
											? "horizontal-top"
											: "horizontal-bottom"
										: "vertical",
									k = I.horizontalLine
										? (n.visibleRangeForPosition(
												new C.$hL(l, I.horizontalLine.endColumn),
											)?.left ?? T + this.j) - T
										: this.j;
								v += `<div class="core-guide ${I.className} ${P}" style="left:${T}px;width:${k}px"></div>`;
							}
							s[y] = v;
						}
						this.m = s;
					}
					r(n, g, p) {
						const o =
								this.q.bracketPairs !== !1
									? this.a.viewModel.getBracketGuidesInRangeByLine(n, g, p, {
											highlightActive: this.q.highlightActiveBracketPair,
											horizontalGuides:
												this.q.bracketPairsHorizontal === !0
													? u.HorizontalGuidesState.Enabled
													: this.q.bracketPairsHorizontal === "active"
														? u.HorizontalGuidesState.EnabledForActive
														: u.HorizontalGuidesState.Disabled,
											includeInactive: this.q.bracketPairs === !0,
										})
									: null,
							f = this.q.indentation
								? this.a.viewModel.getLinesIndentGuides(n, g)
								: null;
						let b = 0,
							s = 0,
							l = 0;
						if (this.q.highlightActiveIndentation !== !1 && p) {
							const v = this.a.viewModel.getActiveIndentGuide(
								p.lineNumber,
								n,
								g,
							);
							(b = v.startLineNumber), (s = v.endLineNumber), (l = v.indent);
						}
						const { indentSize: y } = this.a.viewModel.model.getOptions(),
							$ = [];
						for (let v = n; v <= g; v++) {
							const S = new Array();
							$.push(S);
							const I = o ? o[v - n] : [],
								T = new d.$cc(I),
								P = f ? f[v - n] : 0;
							for (let k = 1; k <= P; k++) {
								const L = (k - 1) * y + 1,
									D =
										(this.q.highlightActiveIndentation === "always" ||
											I.length === 0) &&
										b <= v &&
										v <= s &&
										k === l;
								S.push(...(T.takeWhile((N) => N.visibleColumn < L) || []));
								const M = T.peek();
								(!M || M.visibleColumn !== L || M.horizontalLine) &&
									S.push(
										new u.$CN(
											L,
											-1,
											`core-guide-indent lvl-${(k - 1) % 30}` +
												(D ? " indent-active" : ""),
											null,
											-1,
											-1,
										),
									);
							}
							S.push(...(T.takeWhile((k) => !0) || []));
						}
						return $;
					}
					render(n, g) {
						if (!this.m) return "";
						const p = g - n;
						return p < 0 || p >= this.m.length ? "" : this.m[p];
					}
				}
				e.$tvb = a;
				function h(c) {
					if (!(c && c.isTransparent())) return c;
				}
				(0, w.$oP)((c, n) => {
					const g = [
							{
								bracketColor: i.$_T,
								guideColor: i.$gU,
								guideColorActive: i.$mU,
							},
							{
								bracketColor: i.$aU,
								guideColor: i.$hU,
								guideColorActive: i.$nU,
							},
							{
								bracketColor: i.$bU,
								guideColor: i.$iU,
								guideColorActive: i.$oU,
							},
							{
								bracketColor: i.$cU,
								guideColor: i.$jU,
								guideColorActive: i.$pU,
							},
							{
								bracketColor: i.$dU,
								guideColor: i.$kU,
								guideColorActive: i.$qU,
							},
							{
								bracketColor: i.$eU,
								guideColor: i.$lU,
								guideColorActive: i.$rU,
							},
						],
						p = new r.$DU(),
						o = [
							{ indentColor: i.$HT, indentColorActive: i.$NT },
							{ indentColor: i.$IT, indentColorActive: i.$OT },
							{ indentColor: i.$JT, indentColorActive: i.$PT },
							{ indentColor: i.$KT, indentColorActive: i.$QT },
							{ indentColor: i.$LT, indentColorActive: i.$RT },
							{ indentColor: i.$MT, indentColorActive: i.$ST },
						],
						f = g
							.map((s) => {
								const l = c.getColor(s.bracketColor),
									y = c.getColor(s.guideColor),
									$ = c.getColor(s.guideColorActive),
									v = h(h(y) ?? l?.transparent(0.3)),
									S = h(h($) ?? l);
								if (!(!v || !S)) return { guideColor: v, guideColorActive: S };
							})
							.filter(m.$tg),
						b = o
							.map((s) => {
								const l = c.getColor(s.indentColor),
									y = c.getColor(s.indentColorActive),
									$ = h(l),
									v = h(y);
								if (!(!$ || !v))
									return { indentColor: $, indentColorActive: v };
							})
							.filter(m.$tg);
					if (f.length > 0) {
						for (let s = 0; s < 30; s++) {
							const l = f[s % f.length];
							n.addRule(
								`.monaco-editor .${p.getInlineClassNameOfLevel(s).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`,
							);
						}
						n.addRule(
							".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }",
						),
							n.addRule(
								".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }",
							),
							n.addRule(
								".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }",
							),
							n.addRule(
								`.monaco-editor .vertical.${p.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`,
							),
							n.addRule(
								`.monaco-editor .horizontal-top.${p.activeClassName} { border-top: 1px solid var(--guide-color-active); }`,
							),
							n.addRule(
								`.monaco-editor .horizontal-bottom.${p.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`,
							);
					}
					if (b.length > 0) {
						for (let s = 0; s < 30; s++) {
							const l = b[s % b.length];
							n.addRule(
								`.monaco-editor .lines-content .core-guide-indent.lvl-${s} { --indent-color: ${l.indentColor}; --indent-color-active: ${l.indentColorActive}; }`,
							);
						}
						n.addRule(
							".monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 var(--indent-color) inset; }",
						),
							n.addRule(
								".monaco-editor .lines-content .core-guide-indent.indent-active { box-shadow: 1px 0 0 0 var(--indent-color-active) inset; }",
							);
					}
				});
			},
		),
		define(
			de[1664],
			he([1, 0, 12, 591, 38, 48, 17, 35, 307, 2267]),
			function (ce, e, t, i, w, E, C, d, m) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$avb = void 0),
					(t = mt(t));
				class r extends i.$_ub {
					static {
						this.CLASS_NAME = "line-numbers";
					}
					constructor(a) {
						super(),
							(this.c = a),
							this.w(),
							(this.s = new E.$hL(1, 1)),
							(this.t = null),
							(this.u = 1),
							this.c.addEventHandler(this);
					}
					w() {
						const a = this.c.configuration.options;
						this.g = a.get(w.EditorOption.lineHeight);
						const h = a.get(w.EditorOption.lineNumbers);
						(this.j = h.renderType),
							(this.m = h.renderFn),
							(this.n = a.get(w.EditorOption.renderFinalNewline));
						const c = a.get(w.EditorOption.layoutInfo);
						(this.q = c.lineNumbersLeft), (this.r = c.lineNumbersWidth);
					}
					dispose() {
						this.c.removeEventHandler(this), (this.t = null), super.dispose();
					}
					onConfigurationChanged(a) {
						return this.w(), !0;
					}
					onCursorStateChanged(a) {
						const h = a.selections[0].getPosition();
						this.s =
							this.c.viewModel.coordinatesConverter.convertViewPositionToModelPosition(
								h,
							);
						let c = !1;
						return (
							this.u !== h.lineNumber && ((this.u = h.lineNumber), (c = !0)),
							(this.j === w.RenderLineNumbersType.Relative ||
								this.j === w.RenderLineNumbersType.Interval) &&
								(c = !0),
							c
						);
					}
					onFlushed(a) {
						return !0;
					}
					onLinesChanged(a) {
						return !0;
					}
					onLinesDeleted(a) {
						return !0;
					}
					onLinesInserted(a) {
						return !0;
					}
					onScrollChanged(a) {
						return a.scrollTopChanged;
					}
					onZonesChanged(a) {
						return !0;
					}
					onDecorationsChanged(a) {
						return a.affectsLineNumber;
					}
					y(a) {
						const h =
							this.c.viewModel.coordinatesConverter.convertViewPositionToModelPosition(
								new E.$hL(a, 1),
							);
						if (h.column !== 1) return "";
						const c = h.lineNumber;
						if (this.m) return this.m(c);
						if (this.j === w.RenderLineNumbersType.Relative) {
							const n = Math.abs(this.s.lineNumber - c);
							return n === 0
								? '<span class="relative-current-line-number">' + c + "</span>"
								: String(n);
						}
						if (this.j === w.RenderLineNumbersType.Interval) {
							if (this.s.lineNumber === c || c % 10 === 0) return String(c);
							const n = this.c.viewModel.getLineCount();
							return c === n ? String(c) : "";
						}
						return String(c);
					}
					prepareRender(a) {
						if (this.j === w.RenderLineNumbersType.Off) {
							this.t = null;
							return;
						}
						const h = t.$n ? (this.g % 2 === 0 ? " lh-even" : " lh-odd") : "",
							c = a.visibleRange.startLineNumber,
							n = a.visibleRange.endLineNumber,
							g = this.c.viewModel
								.getDecorationsInViewport(a.visibleRange)
								.filter((b) => !!b.options.lineNumberClassName);
						g.sort((b, s) => C.$iL.compareRangesUsingEnds(b.range, s.range));
						let p = 0;
						const o = this.c.viewModel.getLineCount(),
							f = [];
						for (let b = c; b <= n; b++) {
							const s = b - c;
							let l = this.y(b),
								y = "";
							for (; p < g.length && g[p].range.endLineNumber < b; ) p++;
							for (let $ = p; $ < g.length; $++) {
								const { range: v, options: S } = g[$];
								v.startLineNumber <= b && (y += " " + S.lineNumberClassName);
							}
							if (!l && !y) {
								f[s] = "";
								continue;
							}
							b === o &&
								this.c.viewModel.getLineLength(b) === 0 &&
								(this.n === "off" && (l = ""),
								this.n === "dimmed" && (y += " dimmed-line-number")),
								b === this.u && (y += " active-line-number"),
								(f[s] =
									`<div class="${r.CLASS_NAME}${h}${y}" style="left:${this.q}px;width:${this.r}px;">${l}</div>`);
						}
						this.t = f;
					}
					render(a, h) {
						if (!this.t) return "";
						const c = h - a;
						return c < 0 || c >= this.t.length ? "" : this.t[c];
					}
				}
				(e.$avb = r),
					(0, d.$oP)((u, a) => {
						const h = u.getColor(m.$ET),
							c = u.getColor(m.$UT);
						c
							? a.addRule(
									`.monaco-editor .line-numbers.dimmed-line-number { color: ${c}; }`,
								)
							: h &&
								a.addRule(
									`.monaco-editor .line-numbers.dimmed-line-number { color: ${h.transparent(0.4)}; }`,
								);
					});
			},
		),
		define(
			de[2849],
			he([
				1, 0, 4, 139, 194, 12, 37, 321, 942, 1627, 303, 1664, 1605, 38, 747, 48,
				17, 104, 98, 64, 493, 91, 651, 74, 171, 97, 1502, 39, 5, 2260,
			]),
			function (
				ce,
				e,
				t,
				i,
				w,
				E,
				C,
				d,
				m,
				r,
				u,
				a,
				h,
				c,
				n,
				g,
				p,
				o,
				f,
				b,
				s,
				l,
				y,
				$,
				v,
				S,
				I,
				T,
				P,
			) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$cvb = void 0),
					(t = mt(t)),
					(i = mt(i)),
					(E = mt(E)),
					(C = mt(C)),
					(s = mt(s));
				class k {
					constructor(A, R, O, B, U) {
						(this.b = A),
							(this.modelLineNumber = R),
							(this.distanceToModelLineStart = O),
							(this.widthOfHiddenLineTextBefore = B),
							(this.distanceToModelLineEnd = U),
							(this._visibleTextAreaBrand = void 0),
							(this.startPosition = null),
							(this.endPosition = null),
							(this.visibleTextareaStart = null),
							(this.visibleTextareaEnd = null),
							(this.a = null);
					}
					prepareRender(A) {
						const R = new g.$hL(
								this.modelLineNumber,
								this.distanceToModelLineStart + 1,
							),
							O = new g.$hL(
								this.modelLineNumber,
								this.b.viewModel.model.getLineMaxColumn(this.modelLineNumber) -
									this.distanceToModelLineEnd,
							);
						(this.startPosition =
							this.b.viewModel.coordinatesConverter.convertModelPositionToViewPosition(
								R,
							)),
							(this.endPosition =
								this.b.viewModel.coordinatesConverter.convertModelPositionToViewPosition(
									O,
								)),
							this.startPosition.lineNumber === this.endPosition.lineNumber
								? ((this.visibleTextareaStart = A.visibleRangeForPosition(
										this.startPosition,
									)),
									(this.visibleTextareaEnd = A.visibleRangeForPosition(
										this.endPosition,
									)))
								: ((this.visibleTextareaStart = null),
									(this.visibleTextareaEnd = null));
					}
					definePresentation(A) {
						return (
							this.a ||
								(A
									? (this.a = A)
									: (this.a = {
											foreground: v.ColorId.DefaultForeground,
											italic: !1,
											bold: !1,
											underline: !1,
											strikethrough: !1,
										})),
							this.a
						);
					}
				}
				const L = i.$Ofb;
				let D = class extends u.$yub {
					constructor(A, R, O, B, U) {
						super(A),
							(this.L = B),
							(this.M = U),
							(this.U = new g.$hL(1, 1)),
							(this.W = null),
							(this.a = R),
							(this.b = O),
							(this.c = 0),
							(this.g = 0);
						const z = this._context.configuration.options,
							F = z.get(c.EditorOption.layoutInfo);
						this.R(z),
							(this.s = F.contentLeft),
							(this.t = F.contentWidth),
							(this.u = F.height),
							(this.w = z.get(c.EditorOption.fontInfo)),
							(this.y = z.get(c.EditorOption.lineHeight)),
							(this.z = z.get(c.EditorOption.emptySelectionClipboard)),
							(this.C = z.get(c.EditorOption.copyWithSyntaxHighlighting)),
							(this.F = null),
							(this.G = [new o.$kL(1, 1, 1, 1)]),
							(this.H = [new o.$kL(1, 1, 1, 1)]),
							(this.I = null),
							(this.textArea = (0, w.$Shb)(document.createElement("textarea"))),
							u.$zub.write(this.textArea, u.PartFingerprint.TextArea),
							this.textArea.setClassName(`inputarea ${y.$0ob}`),
							this.textArea.setAttribute(
								"wrap",
								this.n && !this.F ? "on" : "off",
							);
						const { tabSize: x } = this._context.viewModel.model.getOptions();
						(this.textArea.domNode.style.tabSize = `${x * this.w.spaceWidth}px`),
							this.textArea.setAttribute("autocorrect", "off"),
							this.textArea.setAttribute("autocapitalize", "off"),
							this.textArea.setAttribute("autocomplete", "off"),
							this.textArea.setAttribute("spellcheck", "false"),
							this.textArea.setAttribute("aria-label", this.Q(z)),
							this.textArea.setAttribute(
								"aria-required",
								z.get(c.EditorOption.ariaRequired) ? "true" : "false",
							),
							this.textArea.setAttribute(
								"tabindex",
								String(z.get(c.EditorOption.tabIndex)),
							),
							this.textArea.setAttribute("role", "textbox"),
							this.textArea.setAttribute(
								"aria-roledescription",
								t.localize(173, null),
							),
							this.textArea.setAttribute("aria-multiline", "true"),
							this.textArea.setAttribute(
								"aria-autocomplete",
								z.get(c.EditorOption.readOnly) ? "none" : "both",
							),
							this.S(),
							(this.textAreaCover = (0, w.$Shb)(document.createElement("div"))),
							this.textAreaCover.setPosition("absolute");
						const H = {
								getLineCount: () => this._context.viewModel.getLineCount(),
								getLineMaxColumn: (G) =>
									this._context.viewModel.getLineMaxColumn(G),
								getValueInRange: (G, K) =>
									this._context.viewModel.getValueInRange(G, K),
								getValueLengthInRange: (G, K) =>
									this._context.viewModel.getValueLengthInRange(G, K),
								modifyPosition: (G, K) =>
									this._context.viewModel.modifyPosition(G, K),
							},
							q = {
								getDataToCopy: () => {
									const G = this._context.viewModel.getPlainTextToCopy(
											this.H,
											this.z,
											E.$l,
										),
										K = this._context.viewModel.model.getEOL(),
										J = this.z && this.H.length === 1 && this.H[0].isEmpty(),
										W = Array.isArray(G) ? G : null,
										X = Array.isArray(G) ? G.join(K) : G;
									let Y,
										ie = null;
									if (
										m.$5ub.forceCopyWithSyntaxHighlighting ||
										(this.C && X.length < 65536)
									) {
										const ne = this._context.viewModel.getRichTextToCopy(
											this.H,
											this.z,
										);
										ne && ((Y = ne.html), (ie = ne.mode));
									}
									return {
										isFromEmptySelection: J,
										multicursorText: W,
										text: X,
										html: Y,
										mode: ie,
									};
								},
								getScreenReaderContent: () => {
									if (this.j === l.AccessibilitySupport.Disabled) {
										const G = this.G[0];
										if (E.$m && G.isEmpty()) {
											const J = G.getStartPosition();
											let W = this.O(J);
											if ((W.length === 0 && (W = this.P(J)), W.length > 0))
												return new r.$3ub(
													W,
													W.length,
													W.length,
													p.$iL.fromPositions(J),
													0,
												);
										}
										if (
											E.$m &&
											!G.isEmpty() &&
											H.getValueLengthInRange(
												G,
												b.EndOfLinePreference.TextDefined,
											) < 500
										) {
											const J = H.getValueInRange(
												G,
												b.EndOfLinePreference.TextDefined,
											);
											return new r.$3ub(J, 0, J.length, G, 0);
										}
										if (i.$Rfb && !G.isEmpty()) {
											const J = "vscode-placeholder";
											return new r.$3ub(J, 0, J.length, null, void 0);
										}
										return r.$3ub.EMPTY;
									}
									if (i.$Ufb) {
										const G = this.G[0];
										if (G.isEmpty()) {
											const K = G.getStartPosition(),
												[J, W] = this.N(K);
											if (J.length > 0)
												return new r.$3ub(J, W, W, p.$iL.fromPositions(K), 0);
										}
										return r.$3ub.EMPTY;
									}
									return r.$4ub.fromEditorSelection(
										H,
										this.G[0],
										this.m,
										this.j === l.AccessibilitySupport.Unknown,
									);
								},
								deduceModelPosition: (G, K, J) =>
									this._context.viewModel.deduceModelPositionRelativeToViewPosition(
										G,
										K,
										J,
									),
							},
							V = this.D(new m.$9ub(this.textArea.domNode));
						(this.J = this.D(
							this.M.createInstance(m.$7ub, q, V, E.OS, {
								isAndroid: i.$Ufb,
								isChrome: i.$Qfb,
								isFirefox: i.$Ofb,
								isSafari: i.$Rfb,
							}),
						)),
							this.D(
								this.J.onKeyDown((G) => {
									this.a.emitKeyDown(G);
								}),
							),
							this.D(
								this.J.onKeyUp((G) => {
									this.a.emitKeyUp(G);
								}),
							),
							this.D(
								this.J.onPaste((G) => {
									let K = !1,
										J = null,
										W = null;
									G.metadata &&
										((K = this.z && !!G.metadata.isFromEmptySelection),
										(J =
											typeof G.metadata.multicursorText < "u"
												? G.metadata.multicursorText
												: null),
										(W = G.metadata.mode)),
										this.a.paste(G.text, K, J, W);
								}),
							),
							this.D(
								this.J.onCut(() => {
									this.a.cut();
								}),
							),
							this.D(
								this.J.onType((G) => {
									G.replacePrevCharCnt ||
									G.replaceNextCharCnt ||
									G.positionDelta
										? (r.$2ub &&
												console.log(
													` => compositionType: <<${G.text}>>, ${G.replacePrevCharCnt}, ${G.replaceNextCharCnt}, ${G.positionDelta}`,
												),
											this.a.compositionType(
												G.text,
												G.replacePrevCharCnt,
												G.replaceNextCharCnt,
												G.positionDelta,
											))
										: (r.$2ub && console.log(` => type: <<${G.text}>>`),
											this.a.type(G.text));
								}),
							),
							this.D(
								this.J.onSelectionChangeRequest((G) => {
									this.a.setSelection(G);
								}),
							),
							this.D(
								this.J.onCompositionStart((G) => {
									const K = this.textArea.domNode,
										J = this.H[0],
										{
											distanceToModelLineStart: W,
											widthOfHiddenTextBefore: X,
										} = (() => {
											const ie = K.value.substring(
													0,
													Math.min(K.selectionStart, K.selectionEnd),
												),
												ne = ie.lastIndexOf(`
`),
												ee = ie.substring(ne + 1),
												_ = ee.lastIndexOf("	"),
												te = ee.length - _ - 1,
												Q = J.getStartPosition(),
												Z = Math.min(Q.column - 1, te),
												se = Q.column - 1 - Z,
												re = ee.substring(0, ee.length - Z),
												{ tabSize: le } =
													this._context.viewModel.model.getOptions(),
												oe = M(
													this.textArea.domNode.ownerDocument,
													re,
													this.w,
													le,
												);
											return {
												distanceToModelLineStart: se,
												widthOfHiddenTextBefore: oe,
											};
										})(),
										{ distanceToModelLineEnd: Y } = (() => {
											const ie = K.value.substring(
													Math.max(K.selectionStart, K.selectionEnd),
												),
												ne = ie.indexOf(`
`),
												ee = ne === -1 ? ie : ie.substring(0, ne),
												_ = ee.indexOf("	"),
												te = _ === -1 ? ee.length : ee.length - _ - 1,
												Q = J.getEndPosition(),
												Z = Math.min(
													this._context.viewModel.model.getLineMaxColumn(
														Q.lineNumber,
													) - Q.column,
													te,
												);
											return {
												distanceToModelLineEnd:
													this._context.viewModel.model.getLineMaxColumn(
														Q.lineNumber,
													) -
													Q.column -
													Z,
											};
										})();
									this._context.viewModel.revealRange(
										"keyboard",
										!0,
										p.$iL.fromPositions(this.G[0].getStartPosition()),
										s.VerticalRevealType.Simple,
										f.ScrollType.Immediate,
									),
										(this.F = new k(this._context, J.startLineNumber, W, X, Y)),
										this.textArea.setAttribute(
											"wrap",
											this.n && !this.F ? "on" : "off",
										),
										this.F.prepareRender(this.b),
										this.X(),
										this.textArea.setClassName(`inputarea ${y.$0ob} ime-input`),
										this.a.compositionStart(),
										this._context.viewModel.onCompositionStart();
								}),
							),
							this.D(
								this.J.onCompositionUpdate((G) => {
									this.F && (this.F.prepareRender(this.b), this.X());
								}),
							),
							this.D(
								this.J.onCompositionEnd(() => {
									(this.F = null),
										this.textArea.setAttribute(
											"wrap",
											this.n && !this.F ? "on" : "off",
										),
										this.X(),
										this.textArea.setClassName(`inputarea ${y.$0ob}`),
										this.a.compositionEnd(),
										this._context.viewModel.onCompositionEnd();
								}),
							),
							this.D(
								this.J.onFocus(() => {
									this._context.viewModel.setHasFocus(!0);
								}),
							),
							this.D(
								this.J.onBlur(() => {
									this._context.viewModel.setHasFocus(!1);
								}),
							),
							this.D(
								I.IME.onDidChange(() => {
									this.S();
								}),
							);
					}
					writeScreenReaderContent(A) {
						this.J.writeNativeTextAreaContent(A);
					}
					dispose() {
						super.dispose();
					}
					N(A) {
						const R = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?',
							O = this._context.viewModel.getLineContent(A.lineNumber),
							B = (0, n.$QL)(R, []);
						let U = !0,
							z = A.column,
							F = !0,
							x = A.column,
							H = 0;
						for (; H < 50 && (U || F); ) {
							if ((U && z <= 1 && (U = !1), U)) {
								const q = O.charCodeAt(z - 2);
								B.get(q) !== n.WordCharacterClass.Regular ? (U = !1) : z--;
							}
							if ((F && x > O.length && (F = !1), F)) {
								const q = O.charCodeAt(x - 1);
								B.get(q) !== n.WordCharacterClass.Regular ? (F = !1) : x++;
							}
							H++;
						}
						return [O.substring(z - 1, x - 1), A.column - z];
					}
					O(A) {
						const R = this._context.viewModel.getLineContent(A.lineNumber),
							O = (0, n.$QL)(
								this._context.configuration.options.get(
									c.EditorOption.wordSeparators,
								),
								[],
							);
						let B = A.column,
							U = 0;
						for (; B > 1; ) {
							const z = R.charCodeAt(B - 2);
							if (O.get(z) !== n.WordCharacterClass.Regular || U > 50)
								return R.substring(B - 1, A.column - 1);
							U++, B--;
						}
						return R.substring(0, A.column - 1);
					}
					P(A) {
						if (A.column > 1) {
							const O = this._context.viewModel
								.getLineContent(A.lineNumber)
								.charAt(A.column - 2);
							if (!C.$Qf(O.charCodeAt(0))) return O;
						}
						return "";
					}
					Q(A) {
						if (
							A.get(c.EditorOption.accessibilitySupport) ===
							l.AccessibilitySupport.Disabled
						) {
							const O = this.L.lookupKeybinding(
									"editor.action.toggleScreenReaderAccessibilityMode",
								)?.getAriaLabel(),
								B = this.L.lookupKeybinding(
									"workbench.action.showCommands",
								)?.getAriaLabel(),
								U = this.L.lookupKeybinding(
									"workbench.action.openGlobalKeybindings",
								)?.getAriaLabel(),
								z = t.localize(174, null);
							return O
								? t.localize(175, null, z, O)
								: B
									? t.localize(176, null, z, B)
									: U
										? t.localize(177, null, z, U)
										: z;
						}
						return A.get(c.EditorOption.ariaLabel);
					}
					R(A) {
						this.j = A.get(c.EditorOption.accessibilitySupport);
						const R = A.get(c.EditorOption.accessibilityPageSize);
						this.j === l.AccessibilitySupport.Enabled &&
						R === c.EditorOptions.accessibilityPageSize.defaultValue
							? (this.m = 500)
							: (this.m = R);
						const B = A.get(c.EditorOption.layoutInfo).wrappingColumn;
						if (B !== -1 && this.j !== l.AccessibilitySupport.Disabled) {
							const U = A.get(c.EditorOption.fontInfo);
							(this.n = !0),
								(this.q = Math.round(B * U.typicalHalfwidthCharacterWidth));
						} else (this.n = !1), (this.q = L ? 0 : 1);
					}
					onConfigurationChanged(A) {
						const R = this._context.configuration.options,
							O = R.get(c.EditorOption.layoutInfo);
						this.R(R),
							(this.s = O.contentLeft),
							(this.t = O.contentWidth),
							(this.u = O.height),
							(this.w = R.get(c.EditorOption.fontInfo)),
							(this.y = R.get(c.EditorOption.lineHeight)),
							(this.z = R.get(c.EditorOption.emptySelectionClipboard)),
							(this.C = R.get(c.EditorOption.copyWithSyntaxHighlighting)),
							this.textArea.setAttribute(
								"wrap",
								this.n && !this.F ? "on" : "off",
							);
						const { tabSize: B } = this._context.viewModel.model.getOptions();
						return (
							(this.textArea.domNode.style.tabSize = `${B * this.w.spaceWidth}px`),
							this.textArea.setAttribute("aria-label", this.Q(R)),
							this.textArea.setAttribute(
								"aria-required",
								R.get(c.EditorOption.ariaRequired) ? "true" : "false",
							),
							this.textArea.setAttribute(
								"tabindex",
								String(R.get(c.EditorOption.tabIndex)),
							),
							(A.hasChanged(c.EditorOption.domReadOnly) ||
								A.hasChanged(c.EditorOption.readOnly)) &&
								this.S(),
							A.hasChanged(c.EditorOption.accessibilitySupport) &&
								this.J.writeNativeTextAreaContent("strategy changed"),
							!0
						);
					}
					onCursorStateChanged(A) {
						return (
							(this.G = A.selections.slice(0)),
							(this.H = A.modelSelections.slice(0)),
							this.J.writeNativeTextAreaContent("selection changed"),
							!0
						);
					}
					onDecorationsChanged(A) {
						return !0;
					}
					onFlushed(A) {
						return !0;
					}
					onLinesChanged(A) {
						return !0;
					}
					onLinesDeleted(A) {
						return !0;
					}
					onLinesInserted(A) {
						return !0;
					}
					onScrollChanged(A) {
						return (this.c = A.scrollLeft), (this.g = A.scrollTop), !0;
					}
					onZonesChanged(A) {
						return !0;
					}
					isFocused() {
						return this.J.isFocused();
					}
					focusTextArea() {
						this.J.focusTextArea();
					}
					refreshFocusState() {
						this.J.refreshFocusState();
					}
					getLastRenderData() {
						return this.I;
					}
					setAriaOptions(A) {
						A.activeDescendant
							? (this.textArea.setAttribute("aria-haspopup", "true"),
								this.textArea.setAttribute("aria-autocomplete", "list"),
								this.textArea.setAttribute(
									"aria-activedescendant",
									A.activeDescendant,
								))
							: (this.textArea.setAttribute("aria-haspopup", "false"),
								this.textArea.setAttribute("aria-autocomplete", "both"),
								this.textArea.removeAttribute("aria-activedescendant")),
							A.role && this.textArea.setAttribute("role", A.role);
					}
					S() {
						const A = this._context.configuration.options;
						!I.IME.enabled ||
						(A.get(c.EditorOption.domReadOnly) &&
							A.get(c.EditorOption.readOnly))
							? this.textArea.setAttribute("readonly", "true")
							: this.textArea.removeAttribute("readonly");
					}
					prepareRender(A) {
						(this.U = new g.$hL(
							this.G[0].positionLineNumber,
							this.G[0].positionColumn,
						)),
							(this.W = A.visibleRangeForPosition(this.U)),
							this.F?.prepareRender(A);
					}
					render(A) {
						this.J.writeNativeTextAreaContent("render"), this.X();
					}
					X() {
						if (this.F) {
							const O = this.F.visibleTextareaStart,
								B = this.F.visibleTextareaEnd,
								U = this.F.startPosition,
								z = this.F.endPosition;
							if (
								U &&
								z &&
								O &&
								B &&
								B.left >= this.c &&
								O.left <= this.c + this.t
							) {
								const F =
										this._context.viewLayout.getVerticalOffsetForLineNumber(
											this.U.lineNumber,
										) - this.g,
									x = this.Y(
										this.textArea.domNode.value.substr(
											0,
											this.textArea.domNode.selectionStart,
										),
									);
								let H = this.F.widthOfHiddenLineTextBefore,
									q = this.s + O.left - this.c,
									V = B.left - O.left + 1;
								if (q < this.s) {
									const Y = this.s - q;
									(q += Y), (H += Y), (V -= Y);
								}
								V > this.t && (V = this.t);
								const G = this._context.viewModel.getViewLineData(U.lineNumber),
									K = G.tokens.findTokenIndexAtOffset(U.column - 1),
									J = G.tokens.findTokenIndexAtOffset(z.column - 1),
									W = K === J,
									X = this.F.definePresentation(
										W ? G.tokens.getPresentation(K) : null,
									);
								(this.textArea.domNode.scrollTop = x * this.y),
									(this.textArea.domNode.scrollLeft = H),
									this.$({
										lastRenderPosition: null,
										top: F,
										left: q,
										width: V,
										height: this.y,
										useCover: !1,
										color: ($.$lM.getColorMap() || [])[X.foreground],
										italic: X.italic,
										bold: X.bold,
										underline: X.underline,
										strikethrough: X.strikethrough,
									});
							}
							return;
						}
						if (!this.W) {
							this.Z();
							return;
						}
						const A = this.s + this.W.left - this.c;
						if (A < this.s || A > this.s + this.t) {
							this.Z();
							return;
						}
						const R =
							this._context.viewLayout.getVerticalOffsetForLineNumber(
								this.G[0].positionLineNumber,
							) - this.g;
						if (R < 0 || R > this.u) {
							this.Z();
							return;
						}
						if (E.$m || this.j === l.AccessibilitySupport.Enabled) {
							this.$({
								lastRenderPosition: this.U,
								top: R,
								left: this.n ? this.s : A,
								width: this.q,
								height: this.y,
								useCover: !1,
							}),
								(this.textArea.domNode.scrollLeft = this.W.left);
							const O =
								this.J.textAreaState.newlineCountBeforeSelection ??
								this.Y(
									this.textArea.domNode.value.substr(
										0,
										this.textArea.domNode.selectionStart,
									),
								);
							this.textArea.domNode.scrollTop = O * this.y;
							return;
						}
						this.$({
							lastRenderPosition: this.U,
							top: R,
							left: this.n ? this.s : A,
							width: this.q,
							height: L ? 0 : 1,
							useCover: !1,
						});
					}
					Y(A) {
						let R = 0,
							O = -1;
						do {
							if (
								((O = A.indexOf(
									`
`,
									O + 1,
								)),
								O === -1)
							)
								break;
							R++;
						} while (!0);
						return R;
					}
					Z() {
						this.$({
							lastRenderPosition: null,
							top: 0,
							left: 0,
							width: this.q,
							height: L ? 0 : 1,
							useCover: !0,
						});
					}
					$(A) {
						this.I = A.lastRenderPosition;
						const R = this.textArea,
							O = this.textAreaCover;
						(0, d.$jsb)(R, this.w),
							R.setTop(A.top),
							R.setLeft(A.left),
							R.setWidth(A.width),
							R.setHeight(A.height),
							R.setColor(A.color ? S.$UL.Format.CSS.formatHex(A.color) : ""),
							R.setFontStyle(A.italic ? "italic" : ""),
							A.bold && R.setFontWeight("bold"),
							R.setTextDecoration(
								`${A.underline ? " underline" : ""}${A.strikethrough ? " line-through" : ""}`,
							),
							O.setTop(A.useCover ? A.top : 0),
							O.setLeft(A.useCover ? A.left : 0),
							O.setWidth(A.useCover ? A.width : 0),
							O.setHeight(A.useCover ? A.height : 0);
						const B = this._context.configuration.options;
						B.get(c.EditorOption.glyphMargin)
							? O.setClassName(
									"monaco-editor-background textAreaCover " +
										h.$bvb.OUTER_CLASS_NAME,
								)
							: B.get(c.EditorOption.lineNumbers).renderType !==
									c.RenderLineNumbersType.Off
								? O.setClassName(
										"monaco-editor-background textAreaCover " +
											a.$avb.CLASS_NAME,
									)
								: O.setClassName("monaco-editor-background textAreaCover");
					}
				};
				(e.$cvb = D), (e.$cvb = D = Ne([j(3, T.$uZ), j(4, P.$Li)], D));
				function M(N, A, R, O) {
					if (A.length === 0) return 0;
					const B = N.createElement("div");
					(B.style.position = "absolute"),
						(B.style.top = "-50000px"),
						(B.style.width = "50000px");
					const U = N.createElement("span");
					(0, d.$jsb)(U, R),
						(U.style.whiteSpace = "pre"),
						(U.style.tabSize = `${O * R.spaceWidth}px`),
						U.append(A),
						B.appendChild(U),
						N.body.appendChild(B);
					const z = U.offsetWidth;
					return B.remove(), z;
				}
			},
		),
		define(
			de[2850],
			he([1, 0, 194, 97, 303, 48, 74, 307, 38, 290, 24]),
			function (ce, e, t, i, w, E, C, d, m, r, u) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Gvb = void 0);
				class a {
					constructor(o, f) {
						const b = o.options;
						(this.lineHeight = b.get(m.EditorOption.lineHeight)),
							(this.pixelRatio = b.get(m.EditorOption.pixelRatio)),
							(this.overviewRulerLanes = b.get(
								m.EditorOption.overviewRulerLanes,
							)),
							(this.renderBorder = b.get(m.EditorOption.overviewRulerBorder));
						const s = f.getColor(d.$ZT);
						(this.borderColor = s ? s.toString() : null),
							(this.hideCursor = b.get(
								m.EditorOption.hideCursorInOverviewRuler,
							));
						const l = f.getColor(d.$xT);
						this.cursorColorSingle = l ? l.transparent(0.7).toString() : null;
						const y = f.getColor(d.$zT);
						this.cursorColorPrimary = y ? y.transparent(0.7).toString() : null;
						const $ = f.getColor(d.$BT);
						(this.cursorColorSecondary = $
							? $.transparent(0.7).toString()
							: null),
							(this.themeType = f.type);
						const v = b.get(m.EditorOption.minimap),
							S = v.enabled,
							I = v.side,
							T = f.getColor(d.$1T),
							P = C.$lM.getDefaultBackground();
						T
							? (this.backgroundColor = T)
							: S && I === "right"
								? (this.backgroundColor = P)
								: (this.backgroundColor = null);
						const L = b.get(m.EditorOption.layoutInfo).overviewRuler;
						(this.top = L.top),
							(this.right = L.right),
							(this.domWidth = L.width),
							(this.domHeight = L.height),
							this.overviewRulerLanes === 0
								? ((this.canvasWidth = 0), (this.canvasHeight = 0))
								: ((this.canvasWidth = (this.domWidth * this.pixelRatio) | 0),
									(this.canvasHeight = (this.domHeight * this.pixelRatio) | 0));
						const [D, M] = this.c(1, this.canvasWidth, this.overviewRulerLanes);
						(this.x = D), (this.w = M);
					}
					c(o, f, b) {
						const s = f - o;
						if (b >= 3) {
							const l = Math.floor(s / 3),
								y = Math.floor(s / 3),
								$ = s - l - y,
								v = o,
								S = v + l,
								I = v + l + $;
							return [
								[0, v, S, v, I, v, S, v],
								[0, l, $, l + $, y, l + $ + y, $ + y, l + $ + y],
							];
						} else if (b === 2) {
							const l = Math.floor(s / 2),
								y = s - l,
								$ = o,
								v = $ + l;
							return [
								[0, $, $, $, v, $, $, $],
								[0, l, l, l, y, l + y, l + y, l + y],
							];
						} else {
							const l = o,
								y = s;
							return [
								[0, l, l, l, l, l, l, l],
								[0, y, y, y, y, y, y, y],
							];
						}
					}
					equals(o) {
						return (
							this.lineHeight === o.lineHeight &&
							this.pixelRatio === o.pixelRatio &&
							this.overviewRulerLanes === o.overviewRulerLanes &&
							this.renderBorder === o.renderBorder &&
							this.borderColor === o.borderColor &&
							this.hideCursor === o.hideCursor &&
							this.cursorColorSingle === o.cursorColorSingle &&
							this.cursorColorPrimary === o.cursorColorPrimary &&
							this.cursorColorSecondary === o.cursorColorSecondary &&
							this.themeType === o.themeType &&
							i.$UL.equals(this.backgroundColor, o.backgroundColor) &&
							this.top === o.top &&
							this.right === o.right &&
							this.domWidth === o.domWidth &&
							this.domHeight === o.domHeight &&
							this.canvasWidth === o.canvasWidth &&
							this.canvasHeight === o.canvasHeight
						);
					}
				}
				var h;
				(function (p) {
					p[(p.MIN_DECORATION_HEIGHT = 6)] = "MIN_DECORATION_HEIGHT";
				})(h || (h = {}));
				var c;
				(function (p) {
					(p[(p.Left = 1)] = "Left"),
						(p[(p.Center = 2)] = "Center"),
						(p[(p.Right = 4)] = "Right"),
						(p[(p.Full = 7)] = "Full");
				})(c || (c = {}));
				var n;
				(function (p) {
					(p[(p.NotNeeded = 0)] = "NotNeeded"),
						(p[(p.Maybe = 1)] = "Maybe"),
						(p[(p.Needed = 2)] = "Needed");
				})(n || (n = {}));
				class g extends w.$yub {
					constructor(o) {
						super(o),
							(this.c = n.NotNeeded),
							(this.q = []),
							(this.s = []),
							(this.j = (0, t.$Shb)(document.createElement("canvas"))),
							this.j.setClassName("decorationsOverviewRuler"),
							this.j.setPosition("absolute"),
							this.j.setLayerHinting(!0),
							this.j.setContain("strict"),
							this.j.setAttribute("aria-hidden", "true"),
							this.t(!1),
							(this.g = C.$lM.onDidChange((f) => {
								f.changedColorMap && this.t(!0);
							})),
							(this.n = [
								{ position: new E.$hL(1, 1), color: this.m.cursorColorSingle },
							]);
					}
					dispose() {
						super.dispose(), this.g.dispose();
					}
					t(o) {
						const f = new a(this._context.configuration, this._context.theme);
						return this.m && this.m.equals(f)
							? !1
							: ((this.m = f),
								this.j.setTop(this.m.top),
								this.j.setRight(this.m.right),
								this.j.setWidth(this.m.domWidth),
								this.j.setHeight(this.m.domHeight),
								(this.j.domNode.width = this.m.canvasWidth),
								(this.j.domNode.height = this.m.canvasHeight),
								o && this.z(),
								!0);
					}
					u() {
						return (this.c = n.Needed), !0;
					}
					y() {
						return (this.c = n.Maybe), !0;
					}
					onConfigurationChanged(o) {
						return this.t(!1) ? this.u() : !1;
					}
					onCursorStateChanged(o) {
						this.n = [];
						for (let f = 0, b = o.selections.length; f < b; f++) {
							let s = this.m.cursorColorSingle;
							b > 1 &&
								(s =
									f === 0
										? this.m.cursorColorPrimary
										: this.m.cursorColorSecondary),
								this.n.push({
									position: o.selections[f].getPosition(),
									color: s,
								});
						}
						return (
							this.n.sort((f, b) => E.$hL.compare(f.position, b.position)),
							this.y()
						);
					}
					onDecorationsChanged(o) {
						return o.affectsOverviewRuler ? this.y() : !1;
					}
					onFlushed(o) {
						return this.u();
					}
					onScrollChanged(o) {
						return o.scrollHeightChanged ? this.u() : !1;
					}
					onZonesChanged(o) {
						return this.u();
					}
					onThemeChanged(o) {
						return this.t(!1) ? this.u() : !1;
					}
					getDomNode() {
						return this.j.domNode;
					}
					prepareRender(o) {}
					render(o) {
						this.z(), (this.c = n.NotNeeded);
					}
					z() {
						const o = this.m.backgroundColor;
						if (this.m.overviewRulerLanes === 0) {
							this.j.setBackgroundColor(
								o ? i.$UL.Format.CSS.formatHexA(o) : "",
							),
								this.j.setDisplay("none");
							return;
						}
						const f = this._context.viewModel.getAllOverviewRulerDecorations(
							this._context.theme,
						);
						if (
							(f.sort(r.$6sb.compareByRenderingProps),
							this.c === n.Maybe &&
								!r.$6sb.equalsArr(this.q, f) &&
								(this.c = n.Needed),
							this.c === n.Maybe &&
								!(0, u.$yb)(
									this.s,
									this.n,
									(L, D) =>
										L.position.lineNumber === D.position.lineNumber &&
										L.color === D.color,
								) &&
								(this.c = n.Needed),
							this.c === n.Maybe)
						)
							return;
						(this.q = f), (this.s = this.n), this.j.setDisplay("block");
						const b = this.m.canvasWidth,
							s = this.m.canvasHeight,
							l = this.m.lineHeight,
							y = this._context.viewLayout,
							$ = this._context.viewLayout.getScrollHeight(),
							v = s / $,
							S = (h.MIN_DECORATION_HEIGHT * this.m.pixelRatio) | 0,
							I = (S / 2) | 0,
							T = this.j.domNode.getContext("2d");
						o
							? o.isOpaque()
								? ((T.fillStyle = i.$UL.Format.CSS.formatHexA(o)),
									T.fillRect(0, 0, b, s))
								: (T.clearRect(0, 0, b, s),
									(T.fillStyle = i.$UL.Format.CSS.formatHexA(o)),
									T.fillRect(0, 0, b, s))
							: T.clearRect(0, 0, b, s);
						const P = this.m.x,
							k = this.m.w;
						for (const L of f) {
							const D = L.color,
								M = L.data;
							T.fillStyle = D;
							let N = 0,
								A = 0,
								R = 0;
							for (let O = 0, B = M.length / 3; O < B; O++) {
								const U = M[3 * O],
									z = M[3 * O + 1],
									F = M[3 * O + 2];
								let x = (y.getVerticalOffsetForLineNumber(z) * v) | 0,
									H = ((y.getVerticalOffsetForLineNumber(F) + l) * v) | 0;
								if (H - x < S) {
									let V = ((x + H) / 2) | 0;
									V < I ? (V = I) : V + I > s && (V = s - I),
										(x = V - I),
										(H = V + I);
								}
								x > R + 1 || U !== N
									? (O !== 0 && T.fillRect(P[N], A, k[N], R - A),
										(N = U),
										(A = x),
										(R = H))
									: H > R && (R = H);
							}
							T.fillRect(P[N], A, k[N], R - A);
						}
						if (!this.m.hideCursor) {
							const L = (2 * this.m.pixelRatio) | 0,
								D = (L / 2) | 0,
								M = this.m.x[c.Full],
								N = this.m.w[c.Full];
							let A = -100,
								R = -100,
								O = null;
							for (let B = 0, U = this.n.length; B < U; B++) {
								const z = this.n[B].color;
								if (!z) continue;
								const F = this.n[B].position;
								let x =
									(y.getVerticalOffsetForLineNumber(F.lineNumber) * v) | 0;
								x < D ? (x = D) : x + D > s && (x = s - D);
								const H = x - D,
									q = H + L;
								H > R + 1 || z !== O
									? (B !== 0 && O && T.fillRect(M, A, N, R - A),
										(A = H),
										(R = q))
									: q > R && (R = q),
									(O = z),
									(T.fillStyle = z);
							}
							O && T.fillRect(M, A, N, R - A);
						}
						this.m.renderBorder &&
							this.m.borderColor &&
							this.m.overviewRulerLanes > 0 &&
							(T.beginPath(),
							(T.lineWidth = 1),
							(T.strokeStyle = this.m.borderColor),
							T.moveTo(0, 0),
							T.lineTo(0, s),
							T.moveTo(1, 0),
							T.lineTo(b, 0),
							T.stroke());
					}
				}
				e.$Gvb = g;
			},
		),
		define(
			de[2851],
			he([1, 0, 194, 15, 303, 2720, 38, 307, 35, 212, 248, 7, 2277]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Lvb = void 0);
				class h extends w.$yub {
					static {
						this.BLINK_INTERVAL = 500;
					}
					constructor(n) {
						super(n);
						const g = this._context.configuration.options;
						(this.a = g.get(C.EditorOption.readOnly)),
							(this.b = g.get(C.EditorOption.cursorBlinking)),
							(this.c = g.get(C.EditorOption.cursorStyle)),
							(this.g = g.get(C.EditorOption.cursorSmoothCaretAnimation)),
							(this.j = !0),
							(this.m = !1),
							(this.n = !1),
							(this.y = new E.$Tub(this._context, E.CursorPlurality.Single)),
							(this.z = []),
							(this.C = []),
							(this.q = (0, t.$Shb)(document.createElement("div"))),
							this.q.setAttribute("role", "presentation"),
							this.q.setAttribute("aria-hidden", "true"),
							this.I(),
							this.q.appendChild(this.y.getDomNode()),
							(this.s = new i.$Wh()),
							(this.t = new a.$jgb()),
							(this.u = !1),
							(this.w = !1),
							this.H();
					}
					dispose() {
						super.dispose(), this.s.dispose(), this.t.dispose();
					}
					getDomNode() {
						return this.q;
					}
					onCompositionStart(n) {
						return (this.m = !0), this.H(), !0;
					}
					onCompositionEnd(n) {
						return (this.m = !1), this.H(), !0;
					}
					onConfigurationChanged(n) {
						const g = this._context.configuration.options;
						(this.a = g.get(C.EditorOption.readOnly)),
							(this.b = g.get(C.EditorOption.cursorBlinking)),
							(this.c = g.get(C.EditorOption.cursorStyle)),
							(this.g = g.get(C.EditorOption.cursorSmoothCaretAnimation)),
							this.H(),
							this.I(),
							this.y.onConfigurationChanged(n);
						for (let p = 0, o = this.z.length; p < o; p++)
							this.z[p].onConfigurationChanged(n);
						return !0;
					}
					F(n, g, p) {
						const o =
							this.z.length !== g.length ||
							(this.g === "explicit" && p !== u.CursorChangeReason.Explicit);
						if (
							(this.y.setPlurality(
								g.length
									? E.CursorPlurality.MultiPrimary
									: E.CursorPlurality.Single,
							),
							this.y.onCursorPositionChanged(n, o),
							this.H(),
							this.z.length < g.length)
						) {
							const f = g.length - this.z.length;
							for (let b = 0; b < f; b++) {
								const s = new E.$Tub(
									this._context,
									E.CursorPlurality.MultiSecondary,
								);
								this.q.domNode.insertBefore(
									s.getDomNode().domNode,
									this.y.getDomNode().domNode.nextSibling,
								),
									this.z.push(s);
							}
						} else if (this.z.length > g.length) {
							const f = this.z.length - g.length;
							for (let b = 0; b < f; b++)
								this.q.removeChild(this.z[0].getDomNode()), this.z.splice(0, 1);
						}
						for (let f = 0; f < g.length; f++)
							this.z[f].onCursorPositionChanged(g[f], o);
					}
					onCursorStateChanged(n) {
						const g = [];
						for (let o = 0, f = n.selections.length; o < f; o++)
							g[o] = n.selections[o].getPosition();
						this.F(g[0], g.slice(1), n.reason);
						const p = n.selections[0].isEmpty();
						return this.j !== p && ((this.j = p), this.I()), !0;
					}
					onDecorationsChanged(n) {
						return !0;
					}
					onFlushed(n) {
						return !0;
					}
					onFocusChanged(n) {
						return (this.w = n.isFocused), this.H(), !1;
					}
					onLinesChanged(n) {
						return !0;
					}
					onLinesDeleted(n) {
						return !0;
					}
					onLinesInserted(n) {
						return !0;
					}
					onScrollChanged(n) {
						return !0;
					}
					onTokensChanged(n) {
						const g = (p) => {
							for (let o = 0, f = n.ranges.length; o < f; o++)
								if (
									n.ranges[o].fromLineNumber <= p.lineNumber &&
									p.lineNumber <= n.ranges[o].toLineNumber
								)
									return !0;
							return !1;
						};
						if (g(this.y.getPosition())) return !0;
						for (const p of this.z) if (g(p.getPosition())) return !0;
						return !1;
					}
					onZonesChanged(n) {
						return !0;
					}
					G() {
						return this.m || !this.w
							? C.TextEditorCursorBlinkingStyle.Hidden
							: this.a
								? C.TextEditorCursorBlinkingStyle.Solid
								: this.b;
					}
					H() {
						this.s.cancel(), this.t.cancel();
						const n = this.G(),
							g = n === C.TextEditorCursorBlinkingStyle.Hidden,
							p = n === C.TextEditorCursorBlinkingStyle.Solid;
						g ? this.M() : this.L(),
							(this.u = !1),
							this.I(),
							!g &&
								!p &&
								(n === C.TextEditorCursorBlinkingStyle.Blink
									? this.t.cancelAndSet(
											() => {
												this.n ? this.M() : this.L();
											},
											h.BLINK_INTERVAL,
											(0, a.getWindow)(this.q.domNode),
										)
									: this.s.setIfNotSet(() => {
											(this.u = !0), this.I();
										}, h.BLINK_INTERVAL));
					}
					I() {
						this.q.setClassName(this.J());
					}
					J() {
						let n = "cursors-layer";
						switch ((this.j || (n += " has-selection"), this.c)) {
							case C.TextEditorCursorStyle.Line:
								n += " cursor-line-style";
								break;
							case C.TextEditorCursorStyle.Block:
								n += " cursor-block-style";
								break;
							case C.TextEditorCursorStyle.Underline:
								n += " cursor-underline-style";
								break;
							case C.TextEditorCursorStyle.LineThin:
								n += " cursor-line-thin-style";
								break;
							case C.TextEditorCursorStyle.BlockOutline:
								n += " cursor-block-outline-style";
								break;
							case C.TextEditorCursorStyle.UnderlineThin:
								n += " cursor-underline-thin-style";
								break;
							default:
								n += " cursor-line-style";
						}
						if (this.u)
							switch (this.G()) {
								case C.TextEditorCursorBlinkingStyle.Blink:
									n += " cursor-blink";
									break;
								case C.TextEditorCursorBlinkingStyle.Smooth:
									n += " cursor-smooth";
									break;
								case C.TextEditorCursorBlinkingStyle.Phase:
									n += " cursor-phase";
									break;
								case C.TextEditorCursorBlinkingStyle.Expand:
									n += " cursor-expand";
									break;
								case C.TextEditorCursorBlinkingStyle.Solid:
									n += " cursor-solid";
									break;
								default:
									n += " cursor-solid";
							}
						else n += " cursor-solid";
						return (
							(this.g === "on" || this.g === "explicit") &&
								(n += " cursor-smooth-caret-animation"),
							n
						);
					}
					L() {
						this.y.show();
						for (let n = 0, g = this.z.length; n < g; n++) this.z[n].show();
						this.n = !0;
					}
					M() {
						this.y.hide();
						for (let n = 0, g = this.z.length; n < g; n++) this.z[n].hide();
						this.n = !1;
					}
					prepareRender(n) {
						this.y.prepareRender(n);
						for (let g = 0, p = this.z.length; g < p; g++)
							this.z[g].prepareRender(n);
					}
					render(n) {
						const g = [];
						let p = 0;
						const o = this.y.render(n);
						o && (g[p++] = o);
						for (let f = 0, b = this.z.length; f < b; f++) {
							const s = this.z[f].render(n);
							s && (g[p++] = s);
						}
						this.C = g;
					}
					getLastRenderData() {
						return this.C;
					}
				}
				(e.$Lvb = h),
					(0, m.$oP)((c, n) => {
						const g = [
							{ class: ".cursor", foreground: d.$xT, background: d.$yT },
							{
								class: ".cursor-primary",
								foreground: d.$zT,
								background: d.$AT,
							},
							{
								class: ".cursor-secondary",
								foreground: d.$BT,
								background: d.$CT,
							},
						];
						for (const p of g) {
							const o = c.getColor(p.foreground);
							if (o) {
								let f = c.getColor(p.background);
								f || (f = o.opposite()),
									n.addRule(
										`.monaco-editor .cursors-layer ${p.class} { background-color: ${o}; border-color: ${o}; color: ${f}; }`,
									),
									(0, r.$gP)(c.type) &&
										n.addRule(
											`.monaco-editor .cursors-layer.has-selection ${p.class} { border-left: 1px solid ${f}; border-right: 1px solid ${f}; }`,
										);
							}
						}
					});
			},
		),
		define(
			de[2852],
			he([1, 0, 591, 38, 37, 120, 598, 48, 307, 2278]),
			function (ce, e, t, i, w, E, C, d, m) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Nvb = void 0),
					(w = mt(w));
				class r extends t.$_ub {
					constructor(h) {
						super(),
							(this.a = h),
							(this.b = new u(this.a.configuration)),
							(this.c = []),
							(this.g = null),
							this.a.addEventHandler(this);
					}
					dispose() {
						this.a.removeEventHandler(this), (this.g = null), super.dispose();
					}
					onConfigurationChanged(h) {
						const c = new u(this.a.configuration);
						return this.b.equals(c)
							? h.hasChanged(i.EditorOption.layoutInfo)
							: ((this.b = c), !0);
					}
					onCursorStateChanged(h) {
						return (
							(this.c = h.selections), this.b.renderWhitespace === "selection"
						);
					}
					onDecorationsChanged(h) {
						return !0;
					}
					onFlushed(h) {
						return !0;
					}
					onLinesChanged(h) {
						return !0;
					}
					onLinesDeleted(h) {
						return !0;
					}
					onLinesInserted(h) {
						return !0;
					}
					onScrollChanged(h) {
						return h.scrollTopChanged;
					}
					onZonesChanged(h) {
						return !0;
					}
					prepareRender(h) {
						if (this.b.renderWhitespace === "none") {
							this.g = null;
							return;
						}
						const c = h.visibleRange.startLineNumber,
							g = h.visibleRange.endLineNumber - c + 1,
							p = new Array(g);
						for (let f = 0; f < g; f++) p[f] = !0;
						const o = this.a.viewModel.getMinimapLinesRenderingData(
							h.viewportData.startLineNumber,
							h.viewportData.endLineNumber,
							p,
						);
						this.g = [];
						for (
							let f = h.viewportData.startLineNumber;
							f <= h.viewportData.endLineNumber;
							f++
						) {
							const b = f - h.viewportData.startLineNumber,
								s = o.data[b];
							let l = null;
							if (this.b.renderWhitespace === "selection") {
								const y = this.c;
								for (const $ of y) {
									if ($.endLineNumber < f || $.startLineNumber > f) continue;
									const v =
											$.startLineNumber === f ? $.startColumn : s.minColumn,
										S = $.endLineNumber === f ? $.endColumn : s.maxColumn;
									v < S && (l || (l = []), l.push(new C.$Iub(v - 1, S - 1)));
								}
							}
							this.g[b] = this.j(h, f, l, s);
						}
					}
					j(h, c, n, g) {
						if (
							(this.b.renderWhitespace === "selection" && !n) ||
							(this.b.renderWhitespace === "trailing" &&
								g.continuesWithWrappedLine)
						)
							return "";
						const p = this.a.theme.getColor(m.$DT),
							o = this.b.renderWithSVG,
							f = g.content,
							b =
								this.b.stopRenderingLineAfter === -1
									? f.length
									: Math.min(this.b.stopRenderingLineAfter, f.length),
							s = g.continuesWithWrappedLine,
							l = g.minColumn - 1,
							y = this.b.renderWhitespace === "boundary",
							$ = this.b.renderWhitespace === "trailing",
							v = this.b.lineHeight,
							S = this.b.middotWidth,
							I = this.b.wsmiddotWidth,
							T = this.b.spaceWidth,
							P = Math.abs(I - T),
							k = Math.abs(S - T),
							L = P < k ? 11825 : 183,
							D = this.b.canUseHalfwidthRightwardsArrow;
						let M = "",
							N = !1,
							A = w.$Bf(f),
							R;
						A === -1 ? ((N = !0), (A = b), (R = b)) : (R = w.$Df(f));
						let O = 0,
							B = n && n[O],
							U = 0;
						for (let z = l; z < b; z++) {
							const F = f.charCodeAt(z);
							if (
								(B && z >= B.endOffset && (O++, (B = n && n[O])),
								(F !== E.CharCode.Tab && F !== E.CharCode.Space) ||
									($ && !N && z <= R))
							)
								continue;
							if (y && z >= A && z <= R && F === E.CharCode.Space) {
								const H = z - 1 >= 0 ? f.charCodeAt(z - 1) : E.CharCode.Null,
									q = z + 1 < b ? f.charCodeAt(z + 1) : E.CharCode.Null;
								if (H !== E.CharCode.Space && q !== E.CharCode.Space) continue;
							}
							if (y && s && z === b - 1) {
								const H = z - 1 >= 0 ? f.charCodeAt(z - 1) : E.CharCode.Null;
								if (
									F === E.CharCode.Space &&
									H !== E.CharCode.Space &&
									H !== E.CharCode.Tab
								)
									continue;
							}
							if (n && (!B || B.startOffset > z || B.endOffset <= z)) continue;
							const x = h.visibleRangeForPosition(new d.$hL(c, z + 1));
							x &&
								(o
									? ((U = Math.max(U, x.left)),
										F === E.CharCode.Tab
											? (M += this.m(v, T, x.left))
											: (M += `<circle cx="${(x.left + T / 2).toFixed(2)}" cy="${(v / 2).toFixed(2)}" r="${(T / 7).toFixed(2)}" />`))
									: F === E.CharCode.Tab
										? (M += `<div class="mwh" style="left:${x.left}px;height:${v}px;">${D ? "\uFFEB" : "\u2192"}</div>`)
										: (M += `<div class="mwh" style="left:${x.left}px;height:${v}px;">${String.fromCharCode(L)}</div>`));
						}
						return o
							? ((U = Math.round(U + T)),
								`<svg style="bottom:0;position:absolute;width:${U}px;height:${v}px" viewBox="0 0 ${U} ${v}" xmlns="http://www.w3.org/2000/svg" fill="${p}">` +
									M +
									"</svg>")
							: M;
					}
					m(h, c, n) {
						const g = c / 7,
							p = c,
							o = h / 2,
							f = n,
							b = { x: 0, y: g / 2 },
							s = { x: (100 / 125) * p, y: b.y },
							l = { x: s.x - 0.2 * s.x, y: s.y + 0.2 * s.x },
							y = { x: l.x + 0.1 * s.x, y: l.y + 0.1 * s.x },
							$ = { x: y.x + 0.35 * s.x, y: y.y - 0.35 * s.x },
							v = { x: $.x, y: -$.y },
							S = { x: y.x, y: -y.y },
							I = { x: l.x, y: -l.y },
							T = { x: s.x, y: -s.y },
							P = { x: b.x, y: -b.y };
						return `<path d="M ${[b, s, l, y, $, v, S, I, T, P].map((D) => `${(f + D.x).toFixed(2)} ${(o + D.y).toFixed(2)}`).join(" L ")}" />`;
					}
					render(h, c) {
						if (!this.g) return "";
						const n = c - h;
						return n < 0 || n >= this.g.length ? "" : this.g[n];
					}
				}
				e.$Nvb = r;
				class u {
					constructor(h) {
						const c = h.options,
							n = c.get(i.EditorOption.fontInfo),
							g = c.get(i.EditorOption.experimentalWhitespaceRendering);
						g === "off"
							? ((this.renderWhitespace = "none"), (this.renderWithSVG = !1))
							: g === "svg"
								? ((this.renderWhitespace = c.get(
										i.EditorOption.renderWhitespace,
									)),
									(this.renderWithSVG = !0))
								: ((this.renderWhitespace = c.get(
										i.EditorOption.renderWhitespace,
									)),
									(this.renderWithSVG = !1)),
							(this.spaceWidth = n.spaceWidth),
							(this.middotWidth = n.middotWidth),
							(this.wsmiddotWidth = n.wsmiddotWidth),
							(this.canUseHalfwidthRightwardsArrow =
								n.canUseHalfwidthRightwardsArrow),
							(this.lineHeight = c.get(i.EditorOption.lineHeight)),
							(this.stopRenderingLineAfter = c.get(
								i.EditorOption.stopRenderingLineAfter,
							));
					}
					equals(h) {
						return (
							this.renderWhitespace === h.renderWhitespace &&
							this.renderWithSVG === h.renderWithSVG &&
							this.spaceWidth === h.spaceWidth &&
							this.middotWidth === h.middotWidth &&
							this.wsmiddotWidth === h.wsmiddotWidth &&
							this.canUseHalfwidthRightwardsArrow ===
								h.canUseHalfwidthRightwardsArrow &&
							this.lineHeight === h.lineHeight &&
							this.stopRenderingLineAfter === h.stopRenderingLineAfter
						);
					}
				}
			},
		),
		define(
			de[2853],
			he([
				1, 0, 7, 194, 1127, 29, 1662, 2840, 2849, 746, 2798, 2713, 303, 1534,
				2714, 2755, 2847, 2715, 2844, 1191, 2848, 1664, 2841, 2756, 1605, 2757,
				2831, 2716, 2850, 2717, 2718, 2719, 2845, 2851, 2721, 2852, 38, 48, 17,
				104, 98, 64, 750, 2578, 2579, 5, 35,
			]),
			function (
				ce,
				e,
				t,
				i,
				w,
				E,
				C,
				d,
				m,
				r,
				u,
				a,
				h,
				c,
				n,
				g,
				p,
				o,
				f,
				b,
				s,
				l,
				y,
				$,
				v,
				S,
				I,
				T,
				P,
				k,
				L,
				D,
				M,
				N,
				A,
				R,
				O,
				B,
				U,
				z,
				F,
				x,
				H,
				q,
				V,
				G,
				K,
			) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.View = void 0),
					(t = mt(t));
				let J = class extends H.$Xsb {
					constructor(ie, ne, ee, _, te, Q, Z) {
						super(),
							(this.H = Z),
							(this.F = !1),
							(this.j = [new z.$kL(1, 1, 1, 1)]),
							(this.G = null);
						const se = new u.$Zub(ne, _, te, ie);
						(this.g = new V.$xub(ne, ee, _)),
							this.g.addEventHandler(this),
							(this.u = []),
							(this.w = this.H.createInstance(m.$cvb, this.g, se, this.L())),
							this.u.push(this.w),
							(this.z = (0, i.$Shb)(document.createElement("div"))),
							this.z.setClassName("lines-content monaco-editor-background"),
							this.z.setPosition("absolute"),
							(this.domNode = (0, i.$Shb)(document.createElement("div"))),
							this.domNode.setClassName(this.N()),
							this.domNode.setAttribute("role", "code"),
							(this.C = (0, i.$Shb)(document.createElement("div"))),
							h.$zub.write(this.C, h.PartFingerprint.OverflowGuard),
							this.C.setClassName("overflow-guard"),
							(this.c = new f.$nvb(this.g, this.z, this.domNode, this.C)),
							this.u.push(this.c),
							(this.m = new y.$uvb(this.g, this.z)),
							(this.n = new A.$Mvb(this.g)),
							this.u.push(this.n);
						const re = new P.$Gvb(this.g);
						this.u.push(re);
						const le = new D.$Jvb(this.g);
						this.u.push(le);
						const oe = new a.$fvb(this.g);
						this.u.push(oe),
							oe.addDynamicOverlay(new p.$kvb(this.g)),
							oe.addDynamicOverlay(new M.$Kvb(this.g)),
							oe.addDynamicOverlay(new s.$tvb(this.g)),
							oe.addDynamicOverlay(new o.$mvb(this.g)),
							oe.addDynamicOverlay(new R.$Nvb(this.g));
						const ae = new a.$gvb(this.g);
						this.u.push(ae),
							ae.addDynamicOverlay(new p.$lvb(this.g)),
							ae.addDynamicOverlay(new S.$wvb(this.g)),
							ae.addDynamicOverlay(new $.$vvb(this.g)),
							ae.addDynamicOverlay(new l.$avb(this.g)),
							(this.s = new b.$svb(this.g)),
							this.u.push(this.s);
						const pe = new v.$bvb(this.g);
						pe.getDomNode().appendChild(this.n.marginDomNode),
							pe.getDomNode().appendChild(ae.getDomNode()),
							pe.getDomNode().appendChild(this.s.domNode),
							this.u.push(pe),
							(this.q = new g.$ivb(this.g, this.domNode)),
							this.u.push(this.q),
							(this.t = new N.$Lvb(this.g)),
							this.u.push(this.t),
							(this.r = new T.$Fvb(this.g, this.domNode)),
							this.u.push(this.r);
						const $e = new L.$Ivb(this.g);
						this.u.push($e);
						const ye = new n.$hvb(this.g);
						this.u.push(ye);
						const ue = new I.$Evb(this.g);
						if ((this.u.push(ue), re)) {
							const fe = this.c.getOverviewRulerLayoutInfo();
							fe.parent.insertBefore(re.getDomNode(), fe.insertBefore);
						}
						this.z.appendChild(oe.getDomNode()),
							this.z.appendChild($e.domNode),
							this.z.appendChild(this.n.domNode),
							this.z.appendChild(this.m.getDomNode()),
							this.z.appendChild(this.q.domNode),
							this.z.appendChild(this.t.getDomNode()),
							this.C.appendChild(pe.getDomNode()),
							this.C.appendChild(this.c.getDomNode()),
							this.C.appendChild(le.getDomNode()),
							this.C.appendChild(this.w.textArea),
							this.C.appendChild(this.w.textAreaCover),
							this.C.appendChild(this.r.getDomNode()),
							this.C.appendChild(ue.getDomNode()),
							this.C.appendChild(ye.domNode),
							this.domNode.appendChild(this.C),
							Q
								? (Q.appendChild(
										this.q.overflowingContentWidgetsDomNode.domNode,
									),
									Q.appendChild(
										this.r.overflowingOverlayWidgetsDomNode.domNode,
									))
								: (this.domNode.appendChild(
										this.q.overflowingContentWidgetsDomNode,
									),
									this.domNode.appendChild(
										this.r.overflowingOverlayWidgetsDomNode,
									)),
							this.M(),
							(this.y = this.D(new d.$$ub(this.g, se, this.J())));
					}
					I() {
						const ie = this.g.viewModel.model,
							ne = this.g.viewModel.glyphLanes;
						let ee = [],
							_ = 0;
						(ee = ee.concat(
							ie.getAllMarginDecorations().map((te) => {
								const Q =
									te.options.glyphMargin?.position ?? x.GlyphMarginLane.Center;
								return (
									(_ = Math.max(_, te.range.endLineNumber)),
									{
										range: te.range,
										lane: Q,
										persist: te.options.glyphMargin?.persistLane,
									}
								);
							}),
						)),
							(ee = ee.concat(
								this.s.getWidgets().map((te) => {
									const Q = ie.validateRange(te.preference.range);
									return (
										(_ = Math.max(_, Q.endLineNumber)),
										{ range: Q, lane: te.preference.lane }
									);
								}),
							)),
							ee.sort((te, Q) =>
								U.$iL.compareRangesUsingStarts(te.range, Q.range),
							),
							ne.reset(_);
						for (const te of ee) ne.push(te.lane, te.range, te.persist);
						return ne;
					}
					J() {
						return {
							viewDomNode: this.domNode.domNode,
							linesContentDomNode: this.z.domNode,
							viewLinesDomNode: this.m.getDomNode().domNode,
							focusTextArea: () => {
								this.focus();
							},
							dispatchTextAreaEvent: (ie) => {
								this.w.textArea.domNode.dispatchEvent(ie);
							},
							getLastRenderData: () => {
								const ie = this.t.getLastRenderData() || [],
									ne = this.w.getLastRenderData();
								return new C.$Uub(ie, ne);
							},
							renderNow: () => {
								this.render(!0, !1);
							},
							shouldSuppressMouseDownOnViewZone: (ie) =>
								this.n.shouldSuppressMouseDownOnViewZone(ie),
							shouldSuppressMouseDownOnWidget: (ie) =>
								this.q.shouldSuppressMouseDownOnWidget(ie),
							getPositionFromDOMInfo: (ie, ne) => (
								this.P(), this.m.getPositionFromDOMInfo(ie, ne)
							),
							visibleRangeForPosition: (ie, ne) => (
								this.P(), this.m.visibleRangeForPosition(new B.$hL(ie, ne))
							),
							getLineWidth: (ie) => (this.P(), this.m.getLineWidth(ie)),
						};
					}
					L() {
						return {
							visibleRangeForPosition: (ie) => (
								this.P(), this.m.visibleRangeForPosition(ie)
							),
						};
					}
					M() {
						const ne = this.g.configuration.options.get(
							O.EditorOption.layoutInfo,
						);
						this.domNode.setWidth(ne.width),
							this.domNode.setHeight(ne.height),
							this.C.setWidth(ne.width),
							this.C.setHeight(ne.height),
							this.z.setWidth(16777216),
							this.z.setHeight(16777216);
					}
					N() {
						const ie = this.w.isFocused() ? " focused" : "";
						return (
							this.g.configuration.options.get(O.EditorOption.editorClassName) +
							" " +
							(0, K.$mP)(this.g.theme.type) +
							ie
						);
					}
					handleEvents(ie) {
						super.handleEvents(ie), this.O();
					}
					onConfigurationChanged(ie) {
						return this.domNode.setClassName(this.N()), this.M(), !1;
					}
					onCursorStateChanged(ie) {
						return (this.j = ie.selections), !1;
					}
					onDecorationsChanged(ie) {
						return ie.affectsGlyphMargin && (this.F = !0), !1;
					}
					onFocusChanged(ie) {
						return this.domNode.setClassName(this.N()), !1;
					}
					onThemeChanged(ie) {
						return (
							this.g.theme.update(ie.theme),
							this.domNode.setClassName(this.N()),
							!1
						);
					}
					dispose() {
						this.G !== null && (this.G.dispose(), (this.G = null)),
							this.q.overflowingContentWidgetsDomNode.domNode.remove(),
							this.g.removeEventHandler(this),
							this.m.dispose();
						for (const ie of this.u) ie.dispose();
						super.dispose();
					}
					O() {
						if (this.B.isDisposed) throw new E.$gb();
						if (this.G === null) {
							const ie = this.R();
							this.G = X.INSTANCE.scheduleCoordinatedRendering({
								window: t.getWindow(this.domNode?.domNode),
								prepareRenderText: () => {
									if (this.B.isDisposed) throw new E.$gb();
									try {
										return ie.prepareRenderText();
									} finally {
										this.G = null;
									}
								},
								renderText: () => {
									if (this.B.isDisposed) throw new E.$gb();
									return ie.renderText();
								},
								prepareRender: (ne, ee) => {
									if (this.B.isDisposed) throw new E.$gb();
									return ie.prepareRender(ne, ee);
								},
								render: (ne, ee) => {
									if (this.B.isDisposed) throw new E.$gb();
									return ie.render(ne, ee);
								},
							});
						}
					}
					P() {
						const ie = this.R();
						W(() => ie.prepareRenderText());
						const ne = W(() => ie.renderText());
						if (ne) {
							const [ee, _] = ne;
							W(() => ie.prepareRender(ee, _)), W(() => ie.render(ee, _));
						}
					}
					Q() {
						const ie = [];
						let ne = 0;
						for (const ee of this.u) ee.shouldRender() && (ie[ne++] = ee);
						return ie;
					}
					R() {
						return {
							prepareRenderText: () => {
								if (this.F) {
									this.F = !1;
									const ie = this.I();
									this.g.configuration.setGlyphMarginDecorationLaneCount(
										ie.requiredLanes,
									);
								}
								w.inputLatency.onRenderStart();
							},
							renderText: () => {
								if (!this.domNode.domNode.isConnected) return null;
								let ie = this.Q();
								if (!this.m.shouldRender() && ie.length === 0) return null;
								const ne = this.g.viewLayout.getLinesViewportData();
								this.g.viewModel.setViewport(
									ne.startLineNumber,
									ne.endLineNumber,
									ne.centeredLineNumber,
								);
								const ee = new q.$pub(
									this.j,
									ne,
									this.g.viewLayout.getWhitespaceViewportData(),
									this.g.viewModel,
								);
								return (
									this.q.shouldRender() && this.q.onBeforeRender(ee),
									this.m.shouldRender() &&
										(this.m.renderText(ee),
										this.m.onDidRender(),
										(ie = this.Q())),
									[ie, new r.$rub(this.g.viewLayout, ee, this.m)]
								);
							},
							prepareRender: (ie, ne) => {
								for (const ee of ie) ee.prepareRender(ne);
							},
							render: (ie, ne) => {
								for (const ee of ie) ee.render(ne), ee.onDidRender();
							},
						};
					}
					delegateVerticalScrollbarPointerDown(ie) {
						this.c.delegateVerticalScrollbarPointerDown(ie);
					}
					delegateScrollFromMouseWheelEvent(ie) {
						this.c.delegateScrollFromMouseWheelEvent(ie);
					}
					restoreState(ie) {
						this.g.viewModel.viewLayout.setScrollPosition(
							{ scrollTop: ie.scrollTop, scrollLeft: ie.scrollLeft },
							F.ScrollType.Immediate,
						),
							this.g.viewModel.visibleLinesStabilized();
					}
					getOffsetForColumn(ie, ne) {
						const ee = this.g.viewModel.model.validatePosition({
								lineNumber: ie,
								column: ne,
							}),
							_ =
								this.g.viewModel.coordinatesConverter.convertModelPositionToViewPosition(
									ee,
								);
						this.P();
						const te = this.m.visibleRangeForPosition(
							new B.$hL(_.lineNumber, _.column),
						);
						return te ? te.left : -1;
					}
					getTargetAtClientPoint(ie, ne) {
						const ee = this.y.getTargetAtClientPoint(ie, ne);
						return ee
							? c.$Yub.convertViewToModelMouseTarget(
									ee,
									this.g.viewModel.coordinatesConverter,
								)
							: null;
					}
					createOverviewRuler(ie) {
						return new k.$Hvb(this.g, ie);
					}
					change(ie) {
						this.n.changeViewZones(ie), this.O();
					}
					render(ie, ne) {
						if (ne) {
							this.m.forceShouldRender();
							for (const ee of this.u) ee.forceShouldRender();
						}
						ie ? this.P() : this.O();
					}
					writeScreenReaderContent(ie) {
						this.w.writeScreenReaderContent(ie);
					}
					focus() {
						this.w.focusTextArea();
					}
					isFocused() {
						return this.w.isFocused();
					}
					refreshFocusState() {
						this.w.refreshFocusState();
					}
					setAriaOptions(ie) {
						this.w.setAriaOptions(ie);
					}
					addContentWidget(ie) {
						this.q.addWidget(ie.widget), this.layoutContentWidget(ie), this.O();
					}
					layoutContentWidget(ie) {
						this.q.setWidgetPosition(
							ie.widget,
							ie.position?.position ?? null,
							ie.position?.secondaryPosition ?? null,
							ie.position?.preference ?? null,
							ie.position?.positionAffinity ?? null,
						),
							this.O();
					}
					removeContentWidget(ie) {
						this.q.removeWidget(ie.widget), this.O();
					}
					addOverlayWidget(ie) {
						this.r.addWidget(ie.widget), this.layoutOverlayWidget(ie), this.O();
					}
					layoutOverlayWidget(ie) {
						this.r.setWidgetPosition(ie.widget, ie.position) && this.O();
					}
					removeOverlayWidget(ie) {
						this.r.removeWidget(ie.widget), this.O();
					}
					addGlyphMarginWidget(ie) {
						this.s.addWidget(ie.widget), (this.F = !0), this.O();
					}
					layoutGlyphMarginWidget(ie) {
						const ne = ie.position;
						this.s.setWidgetPosition(ie.widget, ne) &&
							((this.F = !0), this.O());
					}
					removeGlyphMarginWidget(ie) {
						this.s.removeWidget(ie.widget), (this.F = !0), this.O();
					}
				};
				(e.View = J), (e.View = J = Ne([j(6, G.$Li)], J));
				function W(Y) {
					try {
						return Y();
					} catch (ie) {
						return (0, E.$4)(ie), null;
					}
				}
				class X {
					static {
						this.INSTANCE = new X();
					}
					constructor() {
						(this.c = []), (this.d = new Map());
					}
					scheduleCoordinatedRendering(ie) {
						return (
							this.c.push(ie),
							this.f(ie.window),
							{
								dispose: () => {
									const ne = this.c.indexOf(ie);
									if (
										ne !== -1 &&
										(this.c.splice(ne, 1), this.c.length === 0)
									) {
										for (const [ee, _] of this.d) _.dispose();
										this.d.clear();
									}
								},
							}
						);
					}
					f(ie) {
						if (!this.d.has(ie)) {
							const ne = () => {
								this.d.delete(ie), this.g();
							};
							this.d.set(ie, t.$ggb(ie, ne, 100));
						}
					}
					g() {
						const ie = this.c.slice(0);
						this.c = [];
						for (const ee of ie) W(() => ee.prepareRenderText());
						const ne = [];
						for (let ee = 0, _ = ie.length; ee < _; ee++) {
							const te = ie[ee];
							ne[ee] = W(() => te.renderText());
						}
						for (let ee = 0, _ = ie.length; ee < _; ee++) {
							const te = ie[ee],
								Q = ne[ee];
							if (!Q) continue;
							const [Z, se] = Q;
							W(() => te.prepareRender(Z, se));
						}
						for (let ee = 0, _ = ie.length; ee < _; ee++) {
							const te = ie[ee],
								Q = ne[ee];
							if (!Q) continue;
							const [Z, se] = Q;
							W(() => te.render(Z, se));
						}
					}
				}
			},
		),
		define(
			de[2854],
			he([1, 0, 6, 3, 17, 307, 35]),
			function (ce, e, t, i, w, E, C) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }), (e.$uU = void 0);
				class d extends i.$1c {
					constructor(u) {
						super(),
							(this.g = u),
							(this.b = new m()),
							(this.f = new t.$re()),
							(this.onDidChange = this.f.event),
							(this.a = u.getOptions().bracketPairColorizationOptions),
							this.D(
								u.bracketPairs.onDidChange((a) => {
									this.f.fire();
								}),
							);
					}
					handleDidChangeOptions(u) {
						this.a = this.g.getOptions().bracketPairColorizationOptions;
					}
					getDecorationsInRange(u, a, h, c) {
						return c
							? []
							: a === void 0
								? []
								: this.a.enabled
									? this.g.bracketPairs
											.getBracketsInRange(u, !0)
											.map((g) => ({
												id: `bracket${g.range.toString()}-${g.nestingLevel}`,
												options: {
													description: "BracketPairColorization",
													inlineClassName: this.b.getInlineClassName(
														g,
														this.a.independentColorPoolPerBracketType,
													),
												},
												ownerId: 0,
												range: g.range,
											}))
											.toArray()
									: [];
					}
					getAllDecorations(u, a) {
						return u === void 0
							? []
							: this.a.enabled
								? this.getDecorationsInRange(
										new w.$iL(1, 1, this.g.getLineCount(), 1),
										u,
										a,
									)
								: [];
					}
				}
				e.$uU = d;
				class m {
					constructor() {
						this.unexpectedClosingBracketClassName =
							"unexpected-closing-bracket";
					}
					getInlineClassName(u, a) {
						return u.isInvalid
							? this.unexpectedClosingBracketClassName
							: this.getInlineClassNameOfLevel(
									a ? u.nestingLevelOfEqualBracketType : u.nestingLevel,
								);
					}
					getInlineClassNameOfLevel(u) {
						return `bracket-highlighting-${u % 30}`;
					}
				}
				(0, C.$oP)((r, u) => {
					const a = [E.$_T, E.$aU, E.$bU, E.$cU, E.$dU, E.$eU],
						h = new m();
					u.addRule(
						`.monaco-editor .${h.unexpectedClosingBracketClassName} { color: ${r.getColor(E.$fU)}; }`,
					);
					const c = a
						.map((n) => r.getColor(n))
						.filter((n) => !!n)
						.filter((n) => !n.isTransparent());
					for (let n = 0; n < 30; n++) {
						const g = c[n % c.length];
						u.addRule(
							`.monaco-editor .${h.getInlineClassNameOfLevel(n)} { color: ${g}; }`,
						);
					}
				});
			},
		),
		define(
			de[2855],
			he([1, 0, 90, 3, 64, 946, 35, 307, 67, 17, 23, 6, 51, 58, 59, 456]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a, h, c, n, g) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$RAc = void 0);
				let p = class extends i.$1c {
					constructor(b, s) {
						super(),
							(this.c = s),
							(this.a = this.D(new a.$re())),
							(this.onDidChangeMarker = this.a.event),
							(this.b = new n.$Gc()),
							(this.q = null),
							b.getModels().forEach((l) => this.g(l)),
							this.D(b.onModelAdded(this.g, this)),
							this.D(b.onModelRemoved(this.h, this)),
							this.D(this.c.onMarkerChanged(this.f, this));
					}
					dispose() {
						super.dispose(), this.b.forEach((b) => b.dispose()), this.b.clear();
					}
					getMarker(b, s) {
						const l = this.b.get(b);
						return (l && l.getMarker(s)) || null;
					}
					getLiveMarkers(b) {
						const s = this.b.get(b);
						return s ? s.getMarkers() : [];
					}
					f(b) {
						b.forEach((s) => {
							const l = this.b.get(s);
							l && this.j(l);
						});
					}
					g(b) {
						const s = new o(b);
						this.b.set(b.uri, s), this.j(s);
					}
					h(b) {
						const s = this.b.get(b.uri);
						s && (s.dispose(), this.b.delete(b.uri)),
							(b.uri.scheme === u.Schemas.inMemory ||
								b.uri.scheme === u.Schemas.internal ||
								b.uri.scheme === u.Schemas.vscode) &&
								this.c
									?.read({ resource: b.uri })
									.map((l) => l.owner)
									.forEach((l) => this.c.remove(l, [b.uri]));
					}
					j(b) {
						const s = this.c.read({ resource: b.model.uri, take: 500 });
						b.update(s) && this.a.fire(b.model);
					}
					addInsertIntoChatCallback(b) {
						return (
							(this.m = b),
							(0, i.$Yc)(() => {
								this.m = void 0;
							})
						);
					}
					callInsertIntoChatCallback(b) {
						this.m && this.m(b);
					}
					addInsertErrorIntoChatCallback(b) {
						return (
							(this.n = b),
							(0, i.$Yc)(() => {
								this.n = void 0;
							})
						);
					}
					callInsertErrorIntoChatCallback(b) {
						this.n && this.n(b);
					}
					addInsertExplainSymbolIntoChatCallback(b) {
						return (
							(this.q = b),
							(0, i.$Yc)(() => {
								this.q = null;
							})
						);
					}
					callInsertExplainSymbolChatCallback(b) {
						this.q
							? this.q(b)
							: console.warn(
									"No callback registered for insertExplainSymbolIntoChatCallback",
								);
					}
				};
				(e.$RAc = p), (e.$RAc = p = Ne([j(0, m.$QO), j(1, t.$aM)], p));
				class o extends i.$1c {
					constructor(b) {
						super(),
							(this.model = b),
							(this.a = new n.$Mc()),
							this.D(
								(0, i.$Yc)(() => {
									this.model.deltaDecorations([...this.a.values()], []),
										this.a.clear();
								}),
							);
					}
					update(b) {
						const { added: s, removed: l } = (0, g.$f)(
							new Set(this.a.keys()),
							new Set(b),
						);
						if (s.length === 0 && l.length === 0) return !1;
						const y = l.map((S) => this.a.get(S)),
							$ = s.map((S) => ({
								range: this.b(this.model, S),
								options: this.c(S),
							})),
							v = this.model.deltaDecorations(y, $);
						for (const S of l) this.a.delete(S);
						for (let S = 0; S < v.length; S++) this.a.set(s[S], v[S]);
						return !0;
					}
					getMarker(b) {
						return this.a.getKey(b.id);
					}
					getMarkers() {
						const b = [];
						return (
							this.a.forEach((s, l) => {
								const y = this.model.getDecorationRange(s);
								y && b.push([y, l]);
							}),
							b
						);
					}
					b(b, s) {
						let l = r.$iL.lift(s);
						if (
							(s.severity === t.MarkerSeverity.Hint &&
								!this.f(s, t.MarkerTag.Unnecessary) &&
								!this.f(s, t.MarkerTag.Deprecated) &&
								(l = l.setEndPosition(l.startLineNumber, l.startColumn + 2)),
							(l = b.validateRange(l)),
							l.isEmpty())
						) {
							const y =
								b.getLineLastNonWhitespaceColumn(l.startLineNumber) ||
								b.getLineMaxColumn(l.startLineNumber);
							if (y === 1 || l.endColumn >= y) return l;
							const $ = b.getWordAtPosition(l.getStartPosition());
							$ &&
								(l = new r.$iL(
									l.startLineNumber,
									$.startColumn,
									l.endLineNumber,
									$.endColumn,
								));
						} else if (
							s.endColumn === Number.MAX_VALUE &&
							s.startColumn === 1 &&
							l.startLineNumber === l.endLineNumber
						) {
							const y = b.getLineFirstNonWhitespaceColumn(s.startLineNumber);
							y < l.endColumn &&
								((l = new r.$iL(
									l.startLineNumber,
									y,
									l.endLineNumber,
									l.endColumn,
								)),
								(s.startColumn = y));
						}
						return l;
					}
					c(b) {
						let s, l, y, $, v;
						switch (b.severity) {
							case t.MarkerSeverity.Hint:
								this.f(b, t.MarkerTag.Deprecated)
									? (s = void 0)
									: this.f(b, t.MarkerTag.Unnecessary)
										? (s = E.ClassName.EditorUnnecessaryDecoration)
										: (s = E.ClassName.EditorHintDecoration),
									(y = 0);
								break;
							case t.MarkerSeverity.AI:
								(s = E.ClassName.EditorAIDecoration),
									(l = (0, C.$jP)(h.$RP)),
									(y = 20),
									(v = {
										color: (0, C.$jP)(h.$RP),
										position: w.MinimapPosition.Inline,
									});
								break;
							case t.MarkerSeverity.Info:
								(s = E.ClassName.EditorInfoDecoration),
									(l = (0, C.$jP)(d.$$T)),
									(y = 10),
									(v = {
										color: (0, C.$jP)(h.$DR),
										position: w.MinimapPosition.Inline,
									});
								break;
							case t.MarkerSeverity.Warning:
								(s = E.ClassName.EditorWarningDecoration),
									(l = (0, C.$jP)(d.$0T)),
									(y = 20),
									(v = {
										color: (0, C.$jP)(h.$ER),
										position: w.MinimapPosition.Inline,
									});
								break;
							case t.MarkerSeverity.Error:
							default:
								(s = E.ClassName.EditorErrorDecoration),
									(l = (0, C.$jP)(d.$9T)),
									(y = 30),
									(v = {
										color: (0, C.$jP)(h.$FR),
										position: w.MinimapPosition.Inline,
									});
								break;
						}
						return (
							b.tags &&
								(b.tags.indexOf(t.MarkerTag.Unnecessary) !== -1 &&
									($ = E.ClassName.EditorUnnecessaryInlineDecoration),
								b.tags.indexOf(t.MarkerTag.Deprecated) !== -1 &&
									($ = E.ClassName.EditorDeprecatedInlineDecoration)),
							{
								description: c.$AV,
								stickiness:
									w.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
								className: s,
								showIfCollapsed: !0,
								overviewRuler: {
									color: l,
									position: w.OverviewRulerLane.Right,
								},
								minimap: v,
								zIndex: y,
								inlineClassName: $,
							}
						);
					}
					f(b, s) {
						return b.tags ? b.tags.indexOf(s) >= 0 : !1;
					}
				}
			},
		),
		define(
			de[1209],
			he([1, 0, 171, 35, 34, 2575, 61]),
			function (ce, e, t, i, w, E, C) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$fPb = void 0),
					(e.$gPb = a);
				var d;
				(function (n) {
					n[(n.NO_STYLING = 2147483647)] = "NO_STYLING";
				})(d || (d = {}));
				const m = !1;
				let r = class {
					constructor(g, p, o, f) {
						(this.e = g),
							(this.f = p),
							(this.g = o),
							(this.h = f),
							(this.b = !1),
							(this.c = !1),
							(this.d = !1),
							(this.a = new c());
					}
					getMetadata(g, p, o) {
						const f = this.g.languageIdCodec.encodeLanguageId(o),
							b = this.a.get(g, p, f);
						let s;
						if (b)
							(s = b.metadata),
								m &&
									this.h.getLevel() === w.LogLevel.Trace &&
									this.h.trace(
										`SemanticTokensProviderStyling [CACHED] ${g} / ${p}: foreground ${t.$2L.getForeground(s)}, fontStyle ${t.$2L.getFontStyle(s).toString(2)}`,
									);
						else {
							let l = this.e.tokenTypes[g];
							const y = [];
							if (l) {
								let $ = p;
								for (let S = 0; $ > 0 && S < this.e.tokenModifiers.length; S++)
									$ & 1 && y.push(this.e.tokenModifiers[S]), ($ = $ >> 1);
								m &&
									$ > 0 &&
									this.h.getLevel() === w.LogLevel.Trace &&
									(this.h.trace(
										`SemanticTokensProviderStyling: unknown token modifier index: ${p.toString(2)} for legend: ${JSON.stringify(this.e.tokenModifiers)}`,
									),
									y.push("not-in-legend"));
								const v = this.f.getColorTheme().getTokenStyleMetadata(l, y, o);
								if (typeof v > "u") s = d.NO_STYLING;
								else {
									if (((s = 0), typeof v.italic < "u")) {
										const S =
											(v.italic ? t.FontStyle.Italic : 0) <<
											t.MetadataConsts.FONT_STYLE_OFFSET;
										s |= S | t.MetadataConsts.SEMANTIC_USE_ITALIC;
									}
									if (typeof v.bold < "u") {
										const S =
											(v.bold ? t.FontStyle.Bold : 0) <<
											t.MetadataConsts.FONT_STYLE_OFFSET;
										s |= S | t.MetadataConsts.SEMANTIC_USE_BOLD;
									}
									if (typeof v.underline < "u") {
										const S =
											(v.underline ? t.FontStyle.Underline : 0) <<
											t.MetadataConsts.FONT_STYLE_OFFSET;
										s |= S | t.MetadataConsts.SEMANTIC_USE_UNDERLINE;
									}
									if (typeof v.strikethrough < "u") {
										const S =
											(v.strikethrough ? t.FontStyle.Strikethrough : 0) <<
											t.MetadataConsts.FONT_STYLE_OFFSET;
										s |= S | t.MetadataConsts.SEMANTIC_USE_STRIKETHROUGH;
									}
									if (v.foreground) {
										const S =
											v.foreground << t.MetadataConsts.FOREGROUND_OFFSET;
										s |= S | t.MetadataConsts.SEMANTIC_USE_FOREGROUND;
									}
									s === 0 && (s = d.NO_STYLING);
								}
							} else
								m &&
									this.h.getLevel() === w.LogLevel.Trace &&
									this.h.trace(
										`SemanticTokensProviderStyling: unknown token type index: ${g} for legend: ${JSON.stringify(this.e.tokenTypes)}`,
									),
									(s = d.NO_STYLING),
									(l = "not-in-legend");
							this.a.add(g, p, f, s),
								m &&
									this.h.getLevel() === w.LogLevel.Trace &&
									this.h.trace(
										`SemanticTokensProviderStyling ${g} (${l}) / ${p} (${y.join(" ")}): foreground ${t.$2L.getForeground(s)}, fontStyle ${t.$2L.getFontStyle(s).toString(2)}`,
									);
						}
						return s;
					}
					warnOverlappingSemanticTokens(g, p) {
						this.b ||
							((this.b = !0),
							this.h.warn(
								`Overlapping semantic tokens detected at lineNumber ${g}, column ${p}`,
							));
					}
					warnInvalidLengthSemanticTokens(g, p) {
						this.c ||
							((this.c = !0),
							this.h.warn(
								`Semantic token with invalid length detected at lineNumber ${g}, column ${p}`,
							));
					}
					warnInvalidEditStart(g, p, o, f, b) {
						this.d ||
							((this.d = !0),
							this.h.warn(
								`Invalid semantic tokens edit detected (previousResultId: ${g}, resultId: ${p}) at edit #${o}: The provided start offset ${f} is outside the previous data (length ${b}).`,
							));
					}
				};
				(e.$fPb = r),
					(e.$fPb = r = Ne([j(1, i.$iP), j(2, C.$nM), j(3, w.$ik)], r));
				var u;
				(function (n) {
					(n[(n.DesiredTokensPerArea = 400)] = "DesiredTokensPerArea"),
						(n[(n.DesiredMaxAreas = 1024)] = "DesiredMaxAreas");
				})(u || (u = {}));
				function a(n, g, p) {
					const o = n.data,
						f = (n.data.length / 5) | 0,
						b = Math.max(
							Math.ceil(f / u.DesiredMaxAreas),
							u.DesiredTokensPerArea,
						),
						s = [];
					let l = 0,
						y = 1,
						$ = 0;
					for (; l < f; ) {
						const v = l;
						let S = Math.min(v + b, f);
						if (S < f) {
							let M = S;
							for (; M - 1 > v && o[5 * M] === 0; ) M--;
							if (M - 1 === v) {
								let N = S;
								for (; N + 1 < f && o[5 * N] === 0; ) N++;
								S = N;
							} else S = M;
						}
						let I = new Uint32Array((S - v) * 4),
							T = 0,
							P = 0,
							k = 0,
							L = 0;
						for (; l < S; ) {
							const M = 5 * l,
								N = o[M],
								A = o[M + 1],
								R = (y + N) | 0,
								O = N === 0 ? ($ + A) | 0 : A,
								B = o[M + 2],
								U = (O + B) | 0,
								z = o[M + 3],
								F = o[M + 4];
							if (U <= O) g.warnInvalidLengthSemanticTokens(R, O + 1);
							else if (k === R && L > O)
								g.warnOverlappingSemanticTokens(R, O + 1);
							else {
								const x = g.getMetadata(z, F, p);
								x !== d.NO_STYLING &&
									(P === 0 && (P = R),
									(I[T] = R - P),
									(I[T + 1] = O),
									(I[T + 2] = U),
									(I[T + 3] = x),
									(T += 4),
									(k = R),
									(L = U));
							}
							(y = R), ($ = O), l++;
						}
						T !== I.length && (I = I.subarray(0, T));
						const D = E.$EN.create(P, I);
						s.push(D);
					}
					return s;
				}
				class h {
					constructor(g, p, o, f) {
						(this.tokenTypeIndex = g),
							(this.tokenModifierSet = p),
							(this.languageId = o),
							(this.metadata = f),
							(this.next = null);
					}
				}
				class c {
					static {
						this.a = [
							3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381,
							32749, 65521, 131071, 262139, 524287, 1048573, 2097143,
						];
					}
					constructor() {
						(this.b = 0),
							(this.c = 0),
							(this.d = c.a[this.c]),
							(this.e = Math.round(
								this.c + 1 < c.a.length ? (2 / 3) * this.d : 0,
							)),
							(this.f = []),
							c.g(this.f, this.d);
					}
					static g(g, p) {
						for (let o = 0; o < p; o++) g[o] = null;
					}
					h(g, p) {
						return ((g << 5) - g + p) | 0;
					}
					j(g, p, o) {
						return this.h(this.h(g, p), o) % this.d;
					}
					get(g, p, o) {
						const f = this.j(g, p, o);
						let b = this.f[f];
						for (; b; ) {
							if (
								b.tokenTypeIndex === g &&
								b.tokenModifierSet === p &&
								b.languageId === o
							)
								return b;
							b = b.next;
						}
						return null;
					}
					add(g, p, o, f) {
						if ((this.b++, this.e !== 0 && this.b >= this.e)) {
							const b = this.f;
							this.c++,
								(this.d = c.a[this.c]),
								(this.e = Math.round(
									this.c + 1 < c.a.length ? (2 / 3) * this.d : 0,
								)),
								(this.f = []),
								c.g(this.f, this.d);
							for (const s of b) {
								let l = s;
								for (; l; ) {
									const y = l.next;
									(l.next = null), this.k(l), (l = y);
								}
							}
						}
						this.k(new h(g, p, o, f));
					}
					k(g) {
						const p = this.j(
							g.tokenTypeIndex,
							g.tokenModifierSet,
							g.languageId,
						);
						(g.next = this.f[p]), (this.f[p] = g);
					}
				}
			},
		),
		define(
			de[2856],
			he([1, 0, 3, 61, 35, 34, 1209, 1180, 20]),
			function (ce, e, t, i, w, E, C, d, m) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$tyc = void 0);
				let r = class extends t.$1c {
					constructor(a, h, c) {
						super(),
							(this.b = a),
							(this.c = h),
							(this.f = c),
							(this.a = new WeakMap()),
							this.D(
								this.b.onDidColorThemeChange(() => {
									this.a = new WeakMap();
								}),
							);
					}
					getStyling(a) {
						return (
							this.a.has(a) ||
								this.a.set(
									a,
									new C.$fPb(a.getLegend(), this.b, this.f, this.c),
								),
							this.a.get(a)
						);
					}
				};
				(e.$tyc = r),
					(e.$tyc = r = Ne([j(0, w.$iP), j(1, E.$ik), j(2, i.$nM)], r)),
					(0, m.$lK)(d.$hPb, r, m.InstantiationType.Delayed);
			},
		),
		define(
			de[499],
			he([1, 0, 7, 159, 58, 6, 3, 56, 71, 8, 39, 30, 51, 35, 10, 2287]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a, h, c, n) {
				"use strict";
				var g;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$w7b = e.$v7b = e.$u7b = e.$t7b = void 0),
					(t = mt(t)),
					(e.$t7b = "aipopup.action.modal.generate"),
					(e.$u7b = "aipopup.action.submit.modal.edit"),
					(e.$v7b = "aipopup.action.modal.gpt4edit");
				let p = a.$Io.as(h.$uP.ColorContribution),
					o = a.$Io.as(c.$nP.ThemingContribution);
				const f = "editor.lineHighlightBackground",
					b = "editor.lineHighlightBorder";
				var s;
				(function (y) {
					let $;
					(function (S) {
						(S[(S.Hidden = 0)] = "Hidden"), (S[(S.Showing = 1)] = "Showing");
					})(($ = y.Type || (y.Type = {}))),
						(y.Hidden = { type: $.Hidden });
					class v {
						constructor(I, T) {
							(this.editorPosition = I),
								(this.widgetPosition = T),
								(this.type = $.Showing);
						}
					}
					y.Showing = v;
				})(s || (s = {}));
				let l = class extends C.$1c {
					static {
						g = this;
					}
					static {
						this.a = [d.ContentWidgetPositionPreference.EXACT];
					}
					constructor($, v, S, I, T) {
						super(),
							(this.g = $),
							(this.h = v),
							(this.j = I),
							(this.m = T),
							(this.c = this.D(new E.$re())),
							(this.onClick = this.c.event),
							(this.f = s.Hidden);
						const P = S.getColorTheme().getColor(f),
							k = S.getColorTheme().getColor(h.$8P);
						this.b = t.$("div.cursorHintLineWidgetBackground");
						const L = t.$("div.cursorHintLineWidget"),
							D = (N) => {
								N &&
									((this.b.style.backgroundColor = N.toString()),
									(this.b.style.zIndex = "4"),
									(this.b.style.width = "5000px"),
									(this.b.style.marginLeft = "2px"),
									(this.b.style.whiteSpace = "nowrap"));
							};
						this.D(
							S.onDidColorThemeChange((N) => {
								const A = this.b.children;
								if (A.length > 0) {
									const O = A[0],
										B = N.getColor(f);
									B
										? (O.style.backgroundColor = B.toString())
										: (O.style.backgroundColor = "");
								}
								const R = N.getColor(h.$8P);
								D(R);
							}),
						),
							D(k),
							(L.style.paddingLeft = "12px"),
							P && (L.style.backgroundColor = P.toString());
						const M = t.$("div.cursorHintLineWidgetText");
						this.n(M),
							t.$fhb(L, M),
							t.$fhb(this.b, L),
							this.D(
								I.onDidChangeContext((N) => {
									if (
										N.affectsSome(
											new Set([m.EditorContextKeys.hasDisplayedDiff.key]),
										)
									) {
										const A = I.getContextKeyValue(
												m.EditorContextKeys.hasDisplayedDiff.key,
											),
											R = I.getContextKeyValue(
												m.EditorContextKeys.editorHasPromptBar.key,
											);
										A || R
											? ((this.b.style.display = "none"),
												(this.b.style.opacity = "0"))
											: ((this.b.style.display = "block"),
												(this.b.style.opacity = "1"));
									}
								}),
							),
							this.D(
								v.onDidUpdateKeybindings(() => {
									this.n(M);
								}),
							),
							this.D(i.$Qhb.ignoreTarget(this.b)),
							this.g.addContentWidget(this),
							this.D(
								this.g.onDidChangeModelContent((N) => {
									const A = this.g.getModel();
									(this.q.type !== s.Type.Showing ||
										!A ||
										this.q.editorPosition.lineNumber >= A.getLineCount()) &&
										this.hide();
								}),
							),
							this.s(),
							this.D(
								this.m.onDidChangeConfiguration((N) => {
									N.affectsConfiguration("editor.fontSize") &&
										setTimeout(() => {
											this.s();
										}, 0);
								}),
							);
					}
					n($, v = !0) {
						const S = this.h.lookupKeybinding(w.$dX),
							I = S ? S.getLabel() + " to chat" : "No shortcut for chat";
						let T;
						if (v) {
							const P = this.h.lookupKeybindings(e.$t7b).at(-1);
							T = P ? P.getLabel() + " to toggle" : "No shortcut for toggle";
						} else {
							const P = this.h.lookupKeybinding(e.$t7b);
							T = P
								? P.getLabel() + " to generate"
								: "No shortcut for generate";
						}
						$.textContent = I + ", " + T;
					}
					updateCmdKShortcut($) {
						const v = this.b.querySelector("div.cursorHintLineWidgetText");
						v && this.n(v, $);
					}
					dispose() {
						super.dispose(), this.g.removeContentWidget(this);
					}
					getId() {
						return "HintLineWidget";
					}
					getDomNode() {
						return this.b;
					}
					getPosition() {
						return this.q === s.Hidden
							? null
							: this.f.type === s.Type.Showing
								? this.f.widgetPosition
								: null;
					}
					update($) {
						if (!this.g.hasTextFocus()) return this.hide();
						const v = this.g.getModel();
						if (!v) return this.hide();
						if (v.getLineCount() === 1 && v.getValue() === "")
							return this.hide();
						(this.q = new s.Showing($, {
							position: { lineNumber: $.lineNumber, column: $.column },
							preference: g.a,
						})),
							this.g.layoutContentWidget(this);
					}
					hide() {
						this.q !== s.Hidden &&
							((this.q = s.Hidden), this.g.layoutContentWidget(this));
					}
					get q() {
						return this.f;
					}
					set q($) {
						this.f = $;
					}
					set r($) {
						this.b.title = $;
					}
					s() {
						const $ = this.m.getValue("editor.fontSize"),
							v = $ * 1.5;
						(this.b.style.fontSize = `${$}px`),
							(this.b.style.lineHeight = `${v}px`);
						const S = this.b.querySelector(".cursorHintLineWidget");
						S &&
							((S.style.fontSize = `${$}px`), (S.style.lineHeight = `${v}px`));
						const I = this.b.querySelector(".cursorHintLineWidgetText");
						I &&
							((I.style.fontSize = `${$}px`), (I.style.lineHeight = `${v}px`));
					}
				};
				(e.$w7b = l),
					(e.$w7b =
						l =
						g =
							Ne([j(1, u.$uZ), j(2, c.$iP), j(3, r.$6j), j(4, n.$gj)], l));
			},
		),
		define(
			de[2857],
			he([1, 0, 7, 159, 97, 3, 56, 35, 2289]),
			function (ce, e, t, i, w, E, C, d) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Slc = void 0),
					(t = mt(t));
				let m = class extends E.$1c {
					constructor(u, a) {
						super(),
							(this.j = u),
							(this.f = null),
							(this.h = !0),
							(this.a = t.$("div.cursorLoadingIndicatorWidgetBackground"));
						const h = t.$("div.loading-indicator-spinner");
						t.$fhb(this.a, h);
						const c = (n) => {
							let g = n.getColor("textLink.foreground"),
								p = new w.$UL(new w.$RL(g.rgba.r, g.rgba.g, g.rgba.b, 0.5));
							(h.style.border = `2px solid ${p.toString()}`),
								(g = n.getColor("list.deemphasizedForeground")),
								(p = new w.$UL(new w.$RL(g.rgba.r, g.rgba.g, g.rgba.b, 0))),
								(h.style.borderBottomColor = `${p.toString()}`);
						};
						a.onDidColorThemeChange(c),
							c(a.getColorTheme()),
							this.D(i.$Qhb.ignoreTarget(this.a)),
							this.j.addContentWidget(this);
					}
					dispose() {
						super.dispose(), this.j.removeContentWidget(this);
					}
					getId() {
						return "LoadingIndicatorWidget";
					}
					getDomNode() {
						return this.a;
					}
					getPosition() {
						return this.h ? null : this.f;
					}
					update(u) {
						(this.f = {
							position: u,
							preference: [C.ContentWidgetPositionPreference.EXACT],
						}),
							(this.h = !1),
							this.j.layoutContentWidget(this);
					}
					hide() {
						(this.h = !0), this.j.layoutContentWidget(this);
					}
				};
				(e.$Slc = m), (e.$Slc = m = Ne([j(1, d.$iP)], m));
			},
		),
		define(
			de[2858],
			he([1, 0, 3, 5, 149, 2857, 45, 8]),
			function (ce, e, t, i, w, E, C, d) {
				"use strict";
				var m;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Tlc = void 0);
				let r = class extends t.$1c {
					static {
						m = this;
					}
					static {
						this.ID = "editor.contrib.loadingIndicatorController";
					}
					static get(a) {
						return a.getContribution(m.ID);
					}
					constructor(a, h, c, n) {
						super(),
							(this.c = h),
							(this.f = n),
							this.D(
								c.onDidChangeContext((g) => {
									this.g();
								}),
							),
							(this.a = a),
							setTimeout(() => {
								this.g();
							}, 200),
							this.D(this.a.onDidChangeModel(() => this.g())),
							this.D(this.a.onDidChangeModelLanguage(() => this.g())),
							this.D(this.a.onDidChangeCursorPosition(() => this.g())),
							(this.b = new w.$Y(() =>
								this.D(h.createInstance(E.$Slc, this.a)),
							)),
							(this.reactiveStorageRoot = this.D(this.f.createScoped(this))),
							this.reactiveStorageRoot.onChangeEffect({
								deps: [() => this.f.nonPersistentStorage.runningGeneration],
								onChange: () => {
									this.g();
								},
								runNowToo: !0,
							});
					}
					g() {
						const a = this.a.getSelection(),
							h = a ? a.getStartPosition() : this.a.getPosition();
						this.f.nonPersistentStorage.runningGeneration
							? this.b.value.update(h)
							: this.b.value.hide();
					}
				};
				(e.$Tlc = r),
					(e.$Tlc = r = m = Ne([j(1, i.$Li), j(2, d.$6j), j(3, C.$0zb)], r));
			},
		),
		define(
			de[2859],
			he([1, 0, 7, 159, 97, 3, 56, 38, 35, 2290]),
			function (ce, e, t, i, w, E, C, d, m) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Qlc = void 0),
					(t = mt(t));
				const r = "textLink.foreground";
				let u = class extends E.$1c {
					constructor(h, c, n) {
						super(),
							(this.h = h),
							(this.j = c),
							(this.f = null),
							(this.a = t.$("div.cursorMultiFileHighlightWidgetBackground"));
						const g = (p) => {
							const o = p.getColor(r),
								f = new w.$UL(new w.$RL(o.rgba.r, o.rgba.g, o.rgba.b, 0.25));
							this.a.style.backgroundColor = f.toString();
						};
						n.onDidColorThemeChange(g),
							g(n.getColorTheme()),
							(this.a.style.zIndex = "0"),
							(this.a.style.width = "1000px"),
							this.D(i.$Qhb.ignoreTarget(this.a)),
							this.h.addContentWidget(this);
					}
					dispose() {
						super.dispose(), this.h.removeContentWidget(this);
					}
					getId() {
						return "MultiFileHighlightWidget" + this.j;
					}
					getDomNode() {
						return this.a;
					}
					getPosition() {
						return this.f;
					}
					update(h, c) {
						this.f = {
							position: { lineNumber: h, column: 1 },
							preference: [C.ContentWidgetPositionPreference.EXACT],
						};
						const n =
							this.h.getOption(d.EditorOption.suggestLineHeight) ||
							this.h.getOption(d.EditorOption.fontInfo).lineHeight;
						(this.a.style.height = `${n * (c - h + 1)}px`),
							this.h.layoutContentWidget(this);
					}
				};
				(e.$Qlc = u), (e.$Qlc = u = Ne([j(2, m.$iP)], u));
			},
		),
		define(
			de[2860],
			he([1, 0, 46, 3, 5, 2859, 45, 1554]),
			function (ce, e, t, i, w, E, C, d) {
				"use strict";
				var m;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Rlc = void 0);
				let r = class extends i.$1c {
					static {
						m = this;
					}
					static {
						this.ID = "editor.contrib.multiFileHighlightController";
					}
					static get(a) {
						return a.getContribution(m.ID);
					}
					constructor(a, h, c) {
						super(),
							(this.c = h),
							(this.f = c),
							(this.a = a),
							setTimeout(() => {
								this.g();
							}, 200),
							this.D(this.a.onDidChangeModel(() => this.g())),
							this.D(this.a.onDidChangeModelLanguage(() => this.g())),
							this.D(this.a.onDidChangeCursorPosition(() => this.g())),
							(this.b = []),
							(this.reactiveStorageRoot = this.D(this.f.createScoped(this))),
							this.reactiveStorageRoot.onChangeEffect({
								deps: [
									() => (0, d.$Nlc)(this.f),
									() => this.f.nonPersistentStorage.multiEditState.chunks,
								],
								onChange: () => {
									this.g();
								},
								runNowToo: !0,
							});
					}
					g() {
						const h = (
							(0, d.$Nlc)(this.f)
								? this.f.nonPersistentStorage.multiEditState.chunks
								: []
						).filter((c) => c.fsPath === this.a.getModel()?.uri.fsPath);
						if (h.length < this.b.length) {
							for (let c = h.length; c < this.b.length; c++)
								this.b[c].dispose();
							this.b = this.b.slice(0, h.length);
						} else if (h.length > this.b.length)
							for (let c = this.b.length; c < h.length; c++)
								this.b.push(this.D(this.c.createInstance(E.$Qlc, this.a, c)));
						for (let c = 0; c < h.length; c++) {
							const n = h[c];
							this.b[c].update(n.startLineNumber, n.endLineNumber);
						}
					}
				};
				(e.$Rlc = r),
					(e.$Rlc = r = m = Ne([j(1, w.$Li), j(2, C.$0zb)], r)),
					(0, t.$qtb)(r.ID, r, t.EditorContributionInstantiation.Eventually);
			},
		),
		define(
			de[2861],
			he([1, 0, 46, 307, 4, 306, 1185, 1624, 2317]),
			function (ce, e, t, i, w, E, C, d) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(0, t.$qtb)(
						C.$Ujc.ID,
						(0, d.$_jc)(() => C.$Ujc),
						t.EditorContributionInstantiation.Eager,
					),
					(0, E.$wP)(
						"editor.placeholder.foreground",
						i.$6T,
						(0, w.localize)(1360, null),
					);
			},
		),
		define(
			de[1665],
			he([1, 0, 288, 3, 56, 98, 64, 307, 35, 127, 116]),
			function (ce, e, t, i, w, E, C, d, m, r, u) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$l9b = void 0);
				class a {
					constructor(c) {
						(this.a = c), (this.j = void 0);
					}
					provide(c, n, g) {
						const p = new i.$Zc();
						(c.canAcceptInBackground = !!this.a?.canAcceptInBackground),
							(c.matchOnLabel =
								c.matchOnDescription =
								c.matchOnDetail =
								c.sortByLabel =
									!1);
						const o = p.add(new i.$2c());
						return (
							(o.value = this.b(c, n, g)),
							p.add(
								this.h(() => {
									(o.value = void 0), (o.value = this.b(c, n));
								}),
							),
							p
						);
					}
					b(c, n, g) {
						const p = new i.$Zc(),
							o = this.i;
						if (o && this.c(o)) {
							const f = { editor: o },
								b = (0, w.$btb)(o);
							if (b) {
								let s = o.saveViewState() ?? void 0;
								p.add(
									b.onDidChangeCursorPosition(() => {
										s = o.saveViewState() ?? void 0;
									}),
								),
									(f.restoreViewState = () => {
										s && o === this.i && o.restoreViewState(s);
									}),
									p.add(
										(0, t.$hb)(n.onCancellationRequested)(() =>
											f.restoreViewState?.(),
										),
									);
							}
							p.add((0, i.$Yc)(() => this.clearDecorations(o))),
								p.add(this.d(f, c, n, g));
						} else p.add(this.e(c, n));
						return p;
					}
					c(c) {
						return !0;
					}
					f({ editor: c }, n) {
						c.setSelection(n.range, u.TextEditorSelectionSource.JUMP),
							c.revealRangeInCenter(n.range, E.ScrollType.Smooth),
							n.preserveFocus || c.focus();
						const g = c.getModel();
						g &&
							"getLineContent" in g &&
							(0, r.$pib)(`${g.getLineContent(n.range.startLineNumber)}`);
					}
					g(c) {
						return (0, w.$$sb)(c) ? c.getModel()?.modified : c.getModel();
					}
					addDecorations(c, n) {
						c.changeDecorations((g) => {
							const p = [];
							this.j &&
								(p.push(this.j.overviewRulerDecorationId),
								p.push(this.j.rangeHighlightId),
								(this.j = void 0));
							const o = [
									{
										range: n,
										options: {
											description: "quick-access-range-highlight",
											className: "rangeHighlight",
											isWholeLine: !0,
										},
									},
									{
										range: n,
										options: {
											description: "quick-access-range-highlight-overview",
											overviewRuler: {
												color: (0, m.$jP)(d.$8T),
												position: C.OverviewRulerLane.Full,
											},
										},
									},
								],
								[f, b] = g.deltaDecorations(p, o);
							this.j = { rangeHighlightId: f, overviewRulerDecorationId: b };
						});
					}
					clearDecorations(c) {
						const n = this.j;
						n &&
							(c.changeDecorations((g) => {
								g.deltaDecorations(
									[n.overviewRulerDecorationId, n.rangeHighlightId],
									[],
								);
							}),
							(this.j = void 0));
					}
				}
				e.$l9b = a;
			},
		),
		define(
			de[1666],
			he([1, 0, 3, 56, 38, 98, 1665, 4]),
			function (ce, e, t, i, w, E, C, d) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$uNc = void 0);
				class m extends C.$l9b {
					static {
						this.PREFIX = ":";
					}
					constructor() {
						super({ canAcceptInBackground: !0 });
					}
					e(u) {
						const a = (0, d.localize)(1361, null);
						return (u.items = [{ label: a }]), (u.ariaLabel = a), t.$1c.None;
					}
					d(u, a, h) {
						const c = u.editor,
							n = new t.$Zc();
						n.add(
							a.onDidAccept((o) => {
								const [f] = a.selectedItems;
								if (f) {
									if (!this.p(c, f.lineNumber)) return;
									this.f(u, {
										range: this.m(f.lineNumber, f.column),
										keyMods: a.keyMods,
										preserveFocus: o.inBackground,
									}),
										o.inBackground || a.hide();
								}
							}),
						);
						const g = () => {
							const o = this.n(c, a.value.trim().substr(m.PREFIX.length)),
								f = this.o(c, o.lineNumber, o.column);
							if (
								((a.items = [
									{ lineNumber: o.lineNumber, column: o.column, label: f },
								]),
								(a.ariaLabel = f),
								!this.p(c, o.lineNumber))
							) {
								this.clearDecorations(c);
								return;
							}
							const b = this.m(o.lineNumber, o.column);
							c.revealRangeInCenter(b, E.ScrollType.Smooth),
								this.addDecorations(c, b);
						};
						g(), n.add(a.onDidChangeValue(() => g()));
						const p = (0, i.$btb)(c);
						return (
							p &&
								p.getOptions().get(w.EditorOption.lineNumbers).renderType ===
									w.RenderLineNumbersType.Relative &&
								(p.updateOptions({ lineNumbers: "on" }),
								n.add(
									(0, t.$Yc)(() =>
										p.updateOptions({ lineNumbers: "relative" }),
									),
								)),
							n
						);
					}
					m(u = 1, a = 1) {
						return {
							startLineNumber: u,
							startColumn: a,
							endLineNumber: u,
							endColumn: a,
						};
					}
					n(u, a) {
						const h = a
								.split(/,|:|#/)
								.map((n) => parseInt(n, 10))
								.filter((n) => !isNaN(n)),
							c = this.r(u) + 1;
						return { lineNumber: h[0] > 0 ? h[0] : c + h[0], column: h[1] };
					}
					o(u, a, h) {
						if (this.p(u, a))
							return this.q(u, a, h)
								? (0, d.localize)(1362, null, a, h)
								: (0, d.localize)(1363, null, a);
						const c = u.getPosition() || { lineNumber: 1, column: 1 },
							n = this.r(u);
						return n > 1
							? (0, d.localize)(1364, null, c.lineNumber, c.column, n)
							: (0, d.localize)(1365, null, c.lineNumber, c.column);
					}
					p(u, a) {
						return !a || typeof a != "number" ? !1 : a > 0 && a <= this.r(u);
					}
					q(u, a, h) {
						if (!h || typeof h != "number") return !1;
						const c = this.g(u);
						if (!c) return !1;
						const n = { lineNumber: a, column: h };
						return c.validatePosition(n).equals(n);
					}
					r(u) {
						return this.g(u)?.getLineCount() ?? 0;
					}
				}
				e.$uNc = m;
			},
		),
		define(
			de[1667],
			he([1, 0, 15, 33, 14, 26, 322, 3, 37, 17, 98, 74, 204, 1665, 4, 69, 214]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a, h, c, n, g, p) {
				"use strict";
				var o;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$m9b = void 0);
				let f = class extends c.$l9b {
					static {
						o = this;
					}
					static {
						this.PREFIX = "@";
					}
					static {
						this.SCOPE_PREFIX = ":";
					}
					static {
						this.PREFIX_BY_CATEGORY = `${this.PREFIX}${this.SCOPE_PREFIX}`;
					}
					constructor(y, $, v = Object.create(null)) {
						super(v),
							(this.l = y),
							(this.m = $),
							(this.a = v),
							(this.a.canAcceptInBackground = !0);
					}
					e(y) {
						return this.r(y, (0, n.localize)(1366, null)), d.$1c.None;
					}
					d(y, $, v, S) {
						const I = y.editor,
							T = this.g(I);
						return T
							? this.l.documentSymbolProvider.has(T)
								? this.t(y, T, $, v, S)
								: this.q(y, T, $, v)
							: d.$1c.None;
					}
					q(y, $, v, S) {
						const I = new d.$Zc();
						return (
							this.r(v, (0, n.localize)(1367, null)),
							(async () =>
								!(await this.s($, I)) ||
								S.isCancellationRequested ||
								I.add(this.t(y, $, v, S)))(),
							I
						);
					}
					r(y, $) {
						(y.items = [{ label: $, index: 0, kind: a.SymbolKind.String }]),
							(y.ariaLabel = $);
					}
					async s(y, $) {
						if (this.l.documentSymbolProvider.has(y)) return !0;
						const v = new t.$0h(),
							S = $.add(
								this.l.documentSymbolProvider.onDidChange(() => {
									this.l.documentSymbolProvider.has(y) &&
										(S.dispose(), v.complete(!0));
								}),
							);
						return $.add((0, d.$Yc)(() => v.complete(!1))), v.p;
					}
					t(y, $, v, S, I) {
						const T = y.editor,
							P = new d.$Zc();
						P.add(
							v.onDidAccept((M) => {
								const [N] = v.selectedItems;
								N &&
									N.range &&
									(this.f(y, {
										range: N.range.selection,
										keyMods: v.keyMods,
										preserveFocus: M.inBackground,
									}),
									I?.handleAccept?.(N),
									M.inBackground || v.hide());
							}),
						),
							P.add(
								v.onDidTriggerItemButton(({ item: M }) => {
									M &&
										M.range &&
										(this.f(y, {
											range: M.range.selection,
											keyMods: v.keyMods,
											forceSideBySide: !0,
										}),
										v.hide());
								}),
							);
						const k = this.x($, S);
						let L;
						const D = async (M) => {
							L?.dispose(!0), (v.busy = !1), (L = new i.$Ce(S)), (v.busy = !0);
							try {
								const N = (0, C.$hs)(v.value.substr(o.PREFIX.length).trim()),
									A = await this.u(k, N, void 0, L.token, $);
								if (S.isCancellationRequested) return;
								if (A.length > 0) {
									if (((v.items = A), M && N.original.length === 0)) {
										const R = (0, p.$jb)(
											A,
											(O) =>
												!!(
													O.type !== "separator" &&
													O.range &&
													r.$iL.containsPosition(O.range.decoration, M)
												),
										);
										R && (v.activeItems = [R]);
									}
								} else
									N.original.length > 0
										? this.r(v, (0, n.localize)(1368, null))
										: this.r(v, (0, n.localize)(1369, null));
							} finally {
								S.isCancellationRequested || (v.busy = !1);
							}
						};
						return (
							P.add(v.onDidChangeValue(() => D(void 0))),
							D(T.getSelection()?.getPosition()),
							P.add(
								v.onDidChangeActive(() => {
									const [M] = v.activeItems;
									M &&
										M.range &&
										(T.revealRangeInCenter(
											M.range.selection,
											u.ScrollType.Smooth,
										),
										this.addDecorations(T, M.range.decoration));
								}),
							),
							P
						);
					}
					async u(y, $, v, S, I) {
						const T = await y;
						if (S.isCancellationRequested) return [];
						const P = $.original.indexOf(o.SCOPE_PREFIX) === 0,
							k = P ? 1 : 0;
						let L, D;
						$.values && $.values.length > 1
							? ((L = (0, C.$is)($.values[0])),
								(D = (0, C.$is)($.values.slice(1))))
							: (L = $);
						let M;
						const N = this.a?.openSideBySideDirection?.();
						N &&
							(M = [
								{
									iconClass:
										N === "right"
											? E.ThemeIcon.asClassName(w.$ak.splitHorizontal)
											: E.ThemeIcon.asClassName(w.$ak.splitVertical),
									tooltip:
										N === "right"
											? (0, n.localize)(1370, null)
											: (0, n.localize)(1371, null),
								},
							]);
						const A = [];
						for (let B = 0; B < T.length; B++) {
							const U = T[B],
								z = (0, m.$sf)(U.name),
								F = `$(${a.SymbolKinds.toIcon(U.kind).id}) ${z}`,
								x = F.length - z.length;
							let H = U.containerName;
							v?.extraContainerLabel &&
								(H
									? (H = `${v.extraContainerLabel} \u2022 ${H}`)
									: (H = v.extraContainerLabel));
							let q, V, G, K;
							if ($.original.length > k) {
								let W = !1;
								if (
									(L !== $ &&
										(([q, V] = (0, C.$es)(F, { ...$, values: void 0 }, k, x)),
										typeof q == "number" && (W = !0)),
									typeof q != "number" &&
										(([q, V] = (0, C.$es)(F, L, k, x)), typeof q != "number"))
								)
									continue;
								if (!W && D) {
									if (
										(H && D.original.length > 0 && ([G, K] = (0, C.$es)(H, D)),
										typeof G != "number")
									)
										continue;
									typeof q == "number" && (q += G);
								}
							}
							const J = U.tags && U.tags.indexOf(a.SymbolTag.Deprecated) >= 0;
							A.push({
								index: B,
								kind: U.kind,
								score: q,
								label: F,
								ariaLabel: (0, a.$hM)(U.name, U.kind),
								description: H,
								highlights: J ? void 0 : { label: V, description: K },
								range: {
									selection: r.$iL.collapseToStart(U.selectionRange),
									decoration: U.range,
								},
								uri: I.uri,
								symbolName: z,
								strikethrough: J,
								buttons: M,
							});
						}
						const R = A.sort((B, U) => (P ? this.w(B, U) : this.v(B, U)));
						let O = [];
						if (P) {
							let F = function () {
									U &&
										typeof B == "number" &&
										z > 0 &&
										(U.label = (0, m.$kf)(s[B] || b, z));
								},
								B,
								U,
								z = 0;
							for (const x of R)
								B !== x.kind
									? (F(),
										(B = x.kind),
										(z = 1),
										(U = { type: "separator" }),
										O.push(U))
									: z++,
									O.push(x);
							F();
						} else
							R.length > 0 &&
								(O = [
									{
										label: (0, n.localize)(1372, null, A.length),
										type: "separator",
									},
									...R,
								]);
						return O;
					}
					v(y, $) {
						if (typeof y.score != "number" && typeof $.score == "number")
							return 1;
						if (typeof y.score == "number" && typeof $.score != "number")
							return -1;
						if (typeof y.score == "number" && typeof $.score == "number") {
							if (y.score > $.score) return -1;
							if (y.score < $.score) return 1;
						}
						return y.index < $.index ? -1 : y.index > $.index ? 1 : 0;
					}
					w(y, $) {
						const v = s[y.kind] || b,
							S = s[$.kind] || b,
							I = v.localeCompare(S);
						return I === 0 ? this.v(y, $) : I;
					}
					async x(y, $) {
						const v = await this.m.getOrCreate(y, $);
						return $.isCancellationRequested ? [] : v.asListOfDocumentSymbols();
					}
				};
				(e.$m9b = f), (e.$m9b = f = o = Ne([j(0, g.$k3), j(1, h.$9Db)], f));
				const b = (0, n.localize)(1373, null),
					s = {
						[a.SymbolKind.Method]: (0, n.localize)(1374, null),
						[a.SymbolKind.Function]: (0, n.localize)(1375, null),
						[a.SymbolKind.Constructor]: (0, n.localize)(1376, null),
						[a.SymbolKind.Variable]: (0, n.localize)(1377, null),
						[a.SymbolKind.Class]: (0, n.localize)(1378, null),
						[a.SymbolKind.Struct]: (0, n.localize)(1379, null),
						[a.SymbolKind.Event]: (0, n.localize)(1380, null),
						[a.SymbolKind.Operator]: (0, n.localize)(1381, null),
						[a.SymbolKind.Interface]: (0, n.localize)(1382, null),
						[a.SymbolKind.Namespace]: (0, n.localize)(1383, null),
						[a.SymbolKind.Package]: (0, n.localize)(1384, null),
						[a.SymbolKind.TypeParameter]: (0, n.localize)(1385, null),
						[a.SymbolKind.Module]: (0, n.localize)(1386, null),
						[a.SymbolKind.Property]: (0, n.localize)(1387, null),
						[a.SymbolKind.Enum]: (0, n.localize)(1388, null),
						[a.SymbolKind.EnumMember]: (0, n.localize)(1389, null),
						[a.SymbolKind.String]: (0, n.localize)(1390, null),
						[a.SymbolKind.File]: (0, n.localize)(1391, null),
						[a.SymbolKind.Array]: (0, n.localize)(1392, null),
						[a.SymbolKind.Number]: (0, n.localize)(1393, null),
						[a.SymbolKind.Boolean]: (0, n.localize)(1394, null),
						[a.SymbolKind.Object]: (0, n.localize)(1395, null),
						[a.SymbolKind.Key]: (0, n.localize)(1396, null),
						[a.SymbolKind.Field]: (0, n.localize)(1397, null),
						[a.SymbolKind.Constant]: (0, n.localize)(1398, null),
					};
			},
		),
		define(
			de[2862],
			he([
				1, 0, 7, 114, 127, 317, 95, 182, 278, 24, 15, 33, 14, 6, 27, 3, 162, 28,
				321, 56, 38, 48, 17, 98, 74, 4, 8, 39, 34, 106, 51, 35, 2318,
			]),
			function (
				ce,
				e,
				t,
				i,
				w,
				E,
				C,
				d,
				m,
				r,
				u,
				a,
				h,
				c,
				n,
				g,
				p,
				o,
				f,
				b,
				s,
				l,
				y,
				$,
				v,
				S,
				I,
				T,
				P,
				k,
				L,
				D,
			) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$ckc = e.$bkc = e.$akc = void 0),
					(t = mt(t)),
					(w = mt(w)),
					(r = mt(r)),
					(f = mt(f)),
					(S = mt(S));
				const M = !1;
				(e.$akc = new I.$5j("renameInputVisible", !1, S.localize(1413, null))),
					(e.$bkc = new I.$5j(
						"renameInputFocused",
						!1,
						S.localize(1414, null),
					));
				let N = class {
					constructor(U, z, F, x, H, q) {
						(this.z = U),
							(this.A = z),
							(this.B = F),
							(this.C = x),
							(this.D = q),
							(this.allowEditorOverflow = !0),
							(this.y = new g.$Zc()),
							(this.x = e.$akc.bindTo(H)),
							(this.l = !1),
							(this.s = 0),
							(this.t = !1),
							(this.m = new Set()),
							(this.q = new p.$le()),
							(this.b = new R()),
							this.y.add(this.b),
							this.z.addContentWidget(this),
							this.y.add(
								this.z.onDidChangeConfiguration((V) => {
									V.hasChanged(s.EditorOption.fontInfo) && this.F();
								}),
							),
							this.y.add(F.onDidColorThemeChange(this.E, this));
					}
					dispose() {
						this.y.dispose(), this.z.removeContentWidget(this);
					}
					getId() {
						return "__renameInputWidget";
					}
					getDomNode() {
						return (
							this.a ||
								((this.a = document.createElement("div")),
								(this.a.className = "monaco-editor rename-box"),
								this.a.appendChild(this.b.domNode),
								(this.d = this.y.add(
									new A(this.a, {
										fontInfo: this.z.getOption(s.EditorOption.fontInfo),
										onFocusChange: (U) => {
											(this.b.input.value = U), (this.l = !1);
										},
										onSelectionChange: () => {
											(this.l = !1), this.acceptInput(!1);
										},
									}),
								)),
								this.y.add(
									this.b.onDidInputChange(() => {
										this.d?.focusedCandidate !== void 0 && (this.l = !0),
											(this.r ??= this.q.elapsed()),
											this.u?.token.isCancellationRequested === !1 &&
												this.u.cancel(),
											this.d?.clearFocus();
									}),
								),
								(this.f = document.createElement("div")),
								(this.f.className = "rename-label"),
								this.a.appendChild(this.f),
								this.F(),
								this.E(this.B.getColorTheme())),
							this.a
						);
					}
					E(U) {
						if (!this.a) return;
						const z = U.getColor(L.$bR),
							F = U.getColor(L.$cR);
						(this.a.style.backgroundColor = String(U.getColor(L.$bQ) ?? "")),
							(this.a.style.boxShadow = z ? ` 0 0 8px 2px ${z}` : ""),
							(this.a.style.border = F ? `1px solid ${F}` : ""),
							(this.a.style.color = String(U.getColor(L.$UR) ?? ""));
						const x = U.getColor(L.$VR);
						(this.b.domNode.style.backgroundColor = String(
							U.getColor(L.$TR) ?? "",
						)),
							(this.b.input.style.backgroundColor = String(
								U.getColor(L.$TR) ?? "",
							)),
							(this.b.domNode.style.borderWidth = x ? "1px" : "0px"),
							(this.b.domNode.style.borderStyle = x ? "solid" : "none"),
							(this.b.domNode.style.borderColor = x?.toString() ?? "none");
					}
					F() {
						if (this.a === void 0) return;
						(0, o.$vg)(
							this.f !== void 0,
							"RenameWidget#_updateFont: _label must not be undefined given _domNode is defined",
						),
							this.z.applyFontInfo(this.b.input);
						const U = this.z.getOption(s.EditorOption.fontInfo);
						this.f.style.fontSize = `${this.G(U.fontSize)}px`;
					}
					G(U) {
						return U * 0.8;
					}
					getPosition() {
						if (!this.o || !this.z.hasModel() || !this.z.getDomNode())
							return null;
						const U = t.$ogb(this.getDomNode().ownerDocument.body),
							z = t.$tgb(this.z.getDomNode()),
							F = this.P();
						(this.g = F + z.top), (this.h = U.height - this.g);
						const x = this.z.getOption(s.EditorOption.lineHeight),
							{ totalHeight: H } = O.getLayoutInfo({ lineHeight: x }),
							q =
								this.h > H * 6
									? [
											b.ContentWidgetPositionPreference.BELOW,
											b.ContentWidgetPositionPreference.ABOVE,
										]
									: [
											b.ContentWidgetPositionPreference.ABOVE,
											b.ContentWidgetPositionPreference.BELOW,
										];
						return { position: this.i, preference: q };
					}
					beforeRender() {
						const [U, z] = this.A;
						return (
							(this.f.innerText = S.localize(
								1415,
								null,
								this.C.lookupKeybinding(U)?.getLabel(),
								this.C.lookupKeybinding(z)?.getLabel(),
							)),
							(this.a.style.minWidth = "200px"),
							null
						);
					}
					afterRender(U) {
						if (U === null) {
							this.cancelInput(!0, "afterRender (because position is null)");
							return;
						}
						if (!this.z.hasModel() || !this.z.getDomNode()) return;
						(0, o.$vg)(this.d),
							(0, o.$vg)(this.g !== void 0),
							(0, o.$vg)(this.h !== void 0);
						const z = t.$zgb(this.b.domNode),
							F = t.$zgb(this.f);
						let x;
						U === b.ContentWidgetPositionPreference.BELOW
							? (x = this.h)
							: (x = this.g),
							this.d.layout({
								height: x - F - z,
								width: t.$vgb(this.b.domNode),
							});
					}
					acceptInput(U) {
						this.Q("invoking acceptInput"), this.H?.(U);
					}
					cancelInput(U, z) {
						this.I?.(U);
					}
					focusNextRenameSuggestion() {
						this.d?.focusNext() || (this.b.input.value = this.j);
					}
					focusPreviousRenameSuggestion() {
						this.d?.focusPrevious() || (this.b.input.value = this.j);
					}
					getInput(U, z, F, x, H) {
						const { start: q, end: V } = this.L(U, z);
						this.w = H;
						const G = new g.$Zc();
						(this.s = 0),
							(this.t = !1),
							x === void 0
								? (this.b.button.style.display = "none")
								: ((this.b.button.style.display = "flex"),
									(this.J = x),
									this.K(z, !1),
									G.add(t.$0fb(this.b.button, "click", () => this.K(z, !0))),
									G.add(
										t.$0fb(this.b.button, t.$$gb.KEY_DOWN, (J) => {
											const W = new i.$7fb(J);
											(W.equals(n.KeyCode.Enter) ||
												W.equals(n.KeyCode.Space)) &&
												(W.stopPropagation(),
												W.preventDefault(),
												this.K(z, !0));
										}),
									)),
							(this.l = !1),
							this.a.classList.toggle("preview", F),
							(this.i = new l.$hL(U.startLineNumber, U.startColumn)),
							(this.j = z),
							(this.b.input.value = z),
							this.b.input.setAttribute("selectionStart", q.toString()),
							this.b.input.setAttribute("selectionEnd", V.toString()),
							(this.b.input.size = Math.max(
								(U.endColumn - U.startColumn) * 1.1,
								20,
							)),
							this.q.reset(),
							G.add(
								(0, g.$Yc)(() => {
									(this.w = void 0), H.dispose(!0);
								}),
							),
							G.add(
								(0, g.$Yc)(() => {
									this.u !== void 0 && (this.u.dispose(!0), (this.u = void 0));
								}),
							),
							G.add((0, g.$Yc)(() => this.m.clear()));
						const K = new u.$0h();
						return (
							K.p.finally(() => {
								G.dispose(), this.O();
							}),
							(this.I = (J) => (
								this.Q("invoking _currentCancelInput"),
								(this.H = void 0),
								(this.I = void 0),
								this.d?.clearCandidates(),
								K.complete(J),
								!0
							)),
							(this.H = (J) => {
								this.Q("invoking _currentAcceptInput"),
									(0, o.$vg)(this.d !== void 0);
								const W = this.d.nCandidates;
								let X, Y;
								const ie = this.d.focusedCandidate;
								if (
									(ie !== void 0
										? (this.Q("using new name from renameSuggestion"),
											(X = ie),
											(Y = { k: "renameSuggestion" }))
										: (this.Q("using new name from inputField"),
											(X = this.b.input.value),
											(Y = this.l
												? { k: "userEditedRenameSuggestion" }
												: { k: "inputField" })),
									X === z || X.trim().length === 0)
								) {
									this.cancelInput(
										!0,
										"_currentAcceptInput (because newName === value || newName.trim().length === 0)",
									);
									return;
								}
								(this.H = void 0),
									(this.I = void 0),
									this.d.clearCandidates(),
									K.complete({
										newName: X,
										wantsPreview: F && J,
										stats: {
											source: Y,
											nRenameSuggestions: W,
											timeBeforeFirstInputFieldEdit: this.r,
											nRenameSuggestionsInvocations: this.s,
											hadAutomaticRenameSuggestionsInvocation: this.t,
										},
									});
							}),
							G.add(
								H.token.onCancellationRequested(() =>
									this.cancelInput(!0, "cts.token.onCancellationRequested"),
								),
							),
							M ||
								G.add(
									this.z.onDidBlurEditorWidget(() =>
										this.cancelInput(
											!this.a?.ownerDocument.hasFocus(),
											"editor.onDidBlurEditorWidget",
										),
									),
								),
							this.M(),
							K.p
						);
					}
					K(U, z) {
						if (
							this.J !== void 0 &&
							(this.u !== void 0 && this.u.dispose(!0),
							(0, o.$vg)(this.w),
							this.b.buttonState !== "stop")
						) {
							this.u = new a.$Ce();
							const F = z
									? v.NewSymbolNameTriggerKind.Invoke
									: v.NewSymbolNameTriggerKind.Automatic,
								x = this.J(F, this.u.token);
							if (x.length === 0) {
								this.b.setSparkleButton();
								return;
							}
							z || (this.t = !0),
								(this.s += 1),
								this.b.setStopButton(),
								this.N(x, U, this.w.token);
						}
					}
					L(U, z) {
						(0, o.$vg)(this.z.hasModel());
						const F = this.z.getSelection();
						let x = 0,
							H = z.length;
						return (
							!y.$iL.isEmpty(F) &&
								!y.$iL.spansMultipleLines(F) &&
								y.$iL.containsRange(U, F) &&
								((x = Math.max(0, F.startColumn - U.startColumn)),
								(H = Math.min(U.endColumn, F.endColumn) - U.startColumn)),
							{ start: x, end: H }
						);
					}
					M() {
						this.Q("invoking _show"),
							this.z.revealLineInCenterIfOutsideViewport(
								this.i.lineNumber,
								$.ScrollType.Smooth,
							),
							(this.o = !0),
							this.x.set(!0),
							this.z.layoutContentWidget(this),
							setTimeout(() => {
								this.b.input.focus(),
									this.b.input.setSelectionRange(
										parseInt(this.b.input.getAttribute("selectionStart")),
										parseInt(this.b.input.getAttribute("selectionEnd")),
									);
							}, 100);
					}
					async N(U, z, F) {
						const x = (...K) => this.Q("_updateRenameCandidates", ...K);
						x("start");
						const H = await (0, u.$Ah)(Promise.allSettled(U), F);
						if ((this.b.setSparkleButton(), H === void 0)) {
							x(
								"returning early - received updateRenameCandidates results - undefined",
							);
							return;
						}
						const q = H.flatMap((K) =>
							K.status === "fulfilled" && (0, o.$tg)(K.value) ? K.value : [],
						);
						x(
							`received updateRenameCandidates results - total (unfiltered) ${q.length} candidates.`,
						);
						const V = r.$Qb(q, (K) => K.newSymbolName);
						x(`distinct candidates - ${V.length} candidates.`);
						const G = V.filter(
							({ newSymbolName: K }) =>
								K.trim().length > 0 &&
								K !== this.b.input.value &&
								K !== z &&
								!this.m.has(K),
						);
						if (
							(x(`valid distinct candidates - ${q.length} candidates.`),
							G.forEach((K) => this.m.add(K.newSymbolName)),
							G.length < 1)
						) {
							x("returning early - no valid distinct candidates");
							return;
						}
						x("setting candidates"),
							this.d.setCandidates(G),
							x("asking editor to re-layout"),
							this.z.layoutContentWidget(this);
					}
					O() {
						this.Q("invoked _hide"),
							(this.o = !1),
							this.x.reset(),
							this.z.layoutContentWidget(this);
					}
					P() {
						const U = this.z.getVisibleRanges();
						let z;
						return (
							U.length > 0
								? (z = U[0].startLineNumber)
								: (this.D.warn(
										"RenameWidget#_getTopForPosition: this should not happen - visibleRanges is empty",
									),
									(z = Math.max(1, this.i.lineNumber - 5))),
							this.z.getTopForLineNumber(this.i.lineNumber) -
								this.z.getTopForLineNumber(z)
						);
					}
					Q(...U) {
						this.D.trace("RenameWidget", ...U);
					}
				};
				(e.$ckc = N),
					(e.$ckc = N =
						Ne([j(2, D.$iP), j(3, T.$uZ), j(4, I.$6j), j(5, P.$ik)], N));
				class A {
					constructor(U, z) {
						(this.i = new g.$Zc()),
							(this.f = 0),
							(this.g = 0),
							(this.d = z.fontInfo.lineHeight),
							(this.h = z.fontInfo.typicalHalfwidthCharacterWidth),
							(this.a = document.createElement("div")),
							(this.a.className = "rename-box rename-candidate-list-container"),
							U.appendChild(this.a),
							(this.b = A.o(this.a, this.j, z.fontInfo)),
							this.b.onDidChangeFocus((F) => {
								F.elements.length === 1 &&
									z.onFocusChange(F.elements[0].newSymbolName);
							}, this.i),
							this.b.onDidChangeSelection((F) => {
								F.elements.length === 1 && z.onSelectionChange();
							}, this.i),
							this.i.add(
								this.b.onDidBlur((F) => {
									this.b.setFocus([]);
								}),
							),
							this.b.style(
								(0, k.$Eyb)({
									listInactiveFocusForeground: L.$lT,
									listInactiveFocusBackground: L.$nT,
								}),
							);
					}
					dispose() {
						this.b.dispose(), this.i.dispose();
					}
					layout({ height: U, width: z }) {
						(this.f = U), (this.g = z);
					}
					setCandidates(U) {
						this.b.splice(0, 0, U);
						const z = this.l(this.b.length),
							F = this.m(U);
						this.b.layout(z, F),
							(this.a.style.height = `${z}px`),
							(this.a.style.width = `${F}px`),
							w.$pib(S.localize(1416, null, U.length));
					}
					clearCandidates() {
						(this.a.style.height = "0px"),
							(this.a.style.width = "0px"),
							this.b.splice(0, this.b.length, []);
					}
					get nCandidates() {
						return this.b.length;
					}
					get focusedCandidate() {
						if (this.b.length === 0) return;
						const U = this.b.getSelectedElements()[0];
						if (U !== void 0) return U.newSymbolName;
						const z = this.b.getFocusedElements()[0];
						if (z !== void 0) return z.newSymbolName;
					}
					focusNext() {
						if (this.b.length === 0) return !1;
						const U = this.b.getFocus();
						if (U.length === 0)
							return this.b.focusFirst(), this.b.reveal(0), !0;
						if (U[0] === this.b.length - 1)
							return this.b.setFocus([]), this.b.reveal(0), !1;
						{
							this.b.focusNext();
							const z = this.b.getFocus()[0];
							return this.b.reveal(z), !0;
						}
					}
					focusPrevious() {
						if (this.b.length === 0) return !1;
						const U = this.b.getFocus();
						if (U.length === 0) {
							this.b.focusLast();
							const z = this.b.getFocus()[0];
							return this.b.reveal(z), !0;
						} else {
							if (U[0] === 0) return this.b.setFocus([]), !1;
							{
								this.b.focusPrevious();
								const z = this.b.getFocus()[0];
								return this.b.reveal(z), !0;
							}
						}
					}
					clearFocus() {
						this.b.setFocus([]);
					}
					get j() {
						const { totalHeight: U } = O.getLayoutInfo({ lineHeight: this.d });
						return U;
					}
					l(U) {
						const z = this.j * U;
						return Math.min(z, this.f, this.j * 7);
					}
					m(U) {
						const z = Math.ceil(
							Math.max(...U.map((x) => x.newSymbolName.length)) * this.h,
						);
						return Math.max(this.g, 25 + z + 10);
					}
					static o(U, z, F) {
						const x = new (class {
								getTemplateId(q) {
									return "candidate";
								}
								getHeight(q) {
									return z;
								}
							})(),
							H = new (class {
								constructor() {
									this.templateId = "candidate";
								}
								renderTemplate(q) {
									return new O(q, F);
								}
								renderElement(q, V, G) {
									G.populate(q);
								}
								disposeTemplate(q) {
									q.dispose();
								}
							})();
						return new m.List("NewSymbolNameCandidates", U, x, [H], {
							keyboardSupport: !1,
							mouseSupport: !0,
							multipleSelectionSupport: !1,
						});
					}
				}
				class R {
					constructor() {
						(this.m = new c.$re()),
							(this.onDidInputChange = this.m.event),
							(this.o = new g.$Zc());
					}
					get domNode() {
						return (
							this.b ||
								((this.b = document.createElement("div")),
								(this.b.className = "rename-input-with-button"),
								(this.b.style.display = "flex"),
								(this.b.style.flexDirection = "row"),
								(this.b.style.alignItems = "center"),
								(this.d = document.createElement("input")),
								(this.d.className = "rename-input"),
								(this.d.type = "text"),
								(this.d.style.border = "none"),
								this.d.setAttribute("aria-label", S.localize(1417, null)),
								this.b.appendChild(this.d),
								(this.f = document.createElement("div")),
								(this.f.className = "rename-suggestions-button"),
								this.f.setAttribute("tabindex", "0"),
								(this.h = S.localize(1418, null)),
								(this.i = S.localize(1419, null)),
								(this.g = (0, E.$1ib)().setupManagedHover(
									(0, C.$cib)("element"),
									this.f,
									this.h,
								)),
								this.o.add(this.g),
								this.b.appendChild(this.f),
								this.o.add(
									t.$0fb(this.input, t.$$gb.INPUT, () => this.m.fire()),
								),
								this.o.add(
									t.$0fb(this.input, t.$$gb.KEY_DOWN, (U) => {
										const z = new i.$7fb(U);
										(z.keyCode === n.KeyCode.LeftArrow ||
											z.keyCode === n.KeyCode.RightArrow) &&
											this.m.fire();
									}),
								),
								this.o.add(
									t.$0fb(this.input, t.$$gb.CLICK, () => this.m.fire()),
								),
								this.o.add(
									t.$0fb(this.input, t.$$gb.FOCUS, () => {
										(this.domNode.style.outlineWidth = "1px"),
											(this.domNode.style.outlineStyle = "solid"),
											(this.domNode.style.outlineOffset = "-1px"),
											(this.domNode.style.outlineColor =
												"var(--vscode-focusBorder)");
									}),
								),
								this.o.add(
									t.$0fb(this.input, t.$$gb.BLUR, () => {
										this.domNode.style.outline = "none";
									}),
								)),
							this.b
						);
					}
					get input() {
						return (0, o.$vg)(this.d), this.d;
					}
					get button() {
						return (0, o.$vg)(this.f), this.f;
					}
					get buttonState() {
						return this.a;
					}
					setSparkleButton() {
						(this.a = "sparkle"),
							(this.j ??= (0, d.$Tib)(h.$ak.sparkle)),
							t.$9fb(this.button),
							this.button.appendChild(this.j),
							this.button.setAttribute(
								"aria-label",
								"Generating new name suggestions",
							),
							this.g?.update(this.h),
							this.input.focus();
					}
					setStopButton() {
						(this.a = "stop"),
							(this.l ??= (0, d.$Tib)(h.$ak.primitiveSquare)),
							t.$9fb(this.button),
							this.button.appendChild(this.l),
							this.button.setAttribute(
								"aria-label",
								"Cancel generating new name suggestions",
							),
							this.g?.update(this.i),
							this.input.focus();
					}
					dispose() {
						this.o.dispose();
					}
				}
				class O {
					static {
						this.a = 2;
					}
					constructor(U, z) {
						(this.b = document.createElement("div")),
							(this.b.className = "rename-box rename-candidate"),
							(this.b.style.display = "flex"),
							(this.b.style.columnGap = "5px"),
							(this.b.style.alignItems = "center"),
							(this.b.style.height = `${z.lineHeight}px`),
							(this.b.style.padding = `${O.a}px`);
						const F = document.createElement("div");
						(F.style.display = "flex"),
							(F.style.alignItems = "center"),
							(F.style.width = F.style.height = `${z.lineHeight * 0.8}px`),
							this.b.appendChild(F),
							(this.d = (0, d.$Tib)(h.$ak.sparkle)),
							(this.d.style.display = "none"),
							F.appendChild(this.d),
							(this.f = document.createElement("div")),
							f.$jsb(this.f, z),
							this.b.appendChild(this.f),
							U.appendChild(this.b);
					}
					populate(U) {
						this.g(U), this.h(U);
					}
					g(U) {
						const z = !!U.tags?.includes(v.NewSymbolNameTag.AIGenerated);
						this.d.style.display = z ? "inherit" : "none";
					}
					h(U) {
						this.f.innerText = U.newSymbolName;
					}
					static getLayoutInfo({ lineHeight: U }) {
						return { totalHeight: U + O.a * 2 };
					}
					dispose() {}
				}
			},
		),
		define(
			de[2863],
			he([
				1, 0, 127, 15, 33, 29, 94, 27, 3, 28, 9, 46, 199, 65, 48, 17, 71, 74,
				69, 125, 439, 440, 4, 11, 81, 8, 5, 43, 34, 40, 84, 30, 32, 2862,
			]),
			function (
				ce,
				e,
				t,
				i,
				w,
				E,
				C,
				d,
				m,
				r,
				u,
				a,
				h,
				c,
				n,
				g,
				p,
				o,
				f,
				b,
				s,
				l,
				y,
				$,
				v,
				S,
				I,
				T,
				P,
				k,
				L,
				D,
				M,
				N,
			) {
				"use strict";
				var A;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$ekc = void 0),
					(e.$dkc = O),
					(y = mt(y));
				class R {
					constructor(x, H, q) {
						(this.c = x), (this.d = H), (this.b = 0), (this.a = q.ordered(x));
					}
					hasProvider() {
						return this.a.length > 0;
					}
					async resolveRenameLocation(x) {
						const H = [];
						for (this.b = 0; this.b < this.a.length; this.b++) {
							const V = this.a[this.b];
							if (!V.resolveRenameLocation) break;
							const G = await V.resolveRenameLocation(this.c, this.d, x);
							if (G) {
								if (G.rejectReason) {
									H.push(G.rejectReason);
									continue;
								}
								return G;
							}
						}
						this.b = 0;
						const q = this.c.getWordAtPosition(this.d);
						return q
							? {
									range: new g.$iL(
										this.d.lineNumber,
										q.startColumn,
										this.d.lineNumber,
										q.endColumn,
									),
									text: q.word,
									rejectReason:
										H.length > 0
											? H.join(`
`)
											: void 0,
								}
							: {
									range: g.$iL.fromPositions(this.d),
									text: "",
									rejectReason:
										H.length > 0
											? H.join(`
`)
											: void 0,
								};
					}
					async provideRenameEdits(x, H) {
						return this.f(x, this.b, [], H);
					}
					async f(x, H, q, V) {
						const G = this.a[H];
						if (!G)
							return {
								edits: [],
								rejectReason: q.join(`
`),
							};
						const K = await G.provideRenameEdits(this.c, this.d, x, V);
						if (K) {
							if (K.rejectReason)
								return this.f(x, H + 1, q.concat(K.rejectReason), V);
						} else return this.f(x, H + 1, q.concat(y.localize(1402, null)), V);
						return K;
					}
				}
				async function O(F, x, H, q) {
					const V = new R(x, H, F),
						G = await V.resolveRenameLocation(w.CancellationToken.None);
					return G?.rejectReason
						? { edits: [], rejectReason: G.rejectReason }
						: V.provideRenameEdits(q, w.CancellationToken.None);
				}
				let B = class {
					static {
						A = this;
					}
					static {
						this.ID = "editor.contrib.renameController";
					}
					static get(x) {
						return x.getContribution(A.ID);
					}
					constructor(x, H, q, V, G, K, J, W, X) {
						(this.d = x),
							(this.f = H),
							(this.g = q),
							(this.h = V),
							(this.j = G),
							(this.l = K),
							(this.m = J),
							(this.n = W),
							(this.o = X),
							(this.b = new m.$Zc()),
							(this.c = new w.$Ce()),
							(this.a = this.b.add(
								this.f.createInstance(N.$ckc, this.d, [
									"acceptRenameInput",
									"acceptRenameInputWithPreview",
								]),
							));
					}
					dispose() {
						this.b.dispose(), this.c.dispose(!0);
					}
					async run() {
						const x = this.l.trace.bind(this.l, "[rename]");
						if (
							(this.c.dispose(!0), (this.c = new w.$Ce()), !this.d.hasModel())
						) {
							x("editor has no model");
							return;
						}
						const H = this.d.getPosition(),
							q = new R(this.d.getModel(), H, this.n.renameProvider);
						if (!q.hasProvider()) {
							x("skeleton has no provider");
							return;
						}
						const V = new s.$Nzb(
							this.d,
							s.CodeEditorStateFlag.Position | s.CodeEditorStateFlag.Value,
							void 0,
							this.c.token,
						);
						let G;
						try {
							x("resolving rename location");
							const _ = q.resolveRenameLocation(V.token);
							this.j.showWhile(_, 250),
								(G = await _),
								x("resolved rename location");
						} catch (_) {
							_ instanceof E.$9
								? x(
										"resolve rename location cancelled",
										JSON.stringify(_, null, "	"),
									)
								: (x(
										"resolve rename location failed",
										_ instanceof Error ? _ : JSON.stringify(_, null, "	"),
									),
									(typeof _ == "string" || (0, C.$el)(_)) &&
										l.$Szb
											.get(this.d)
											?.showMessage(_ || y.localize(1403, null), H));
							return;
						} finally {
							V.dispose();
						}
						if (!G) {
							x("returning early - no loc");
							return;
						}
						if (G.rejectReason) {
							x(
								`returning early - rejected with reason: ${G.rejectReason}`,
								G.rejectReason,
							),
								l.$Szb.get(this.d)?.showMessage(G.rejectReason, H);
							return;
						}
						if (V.token.isCancellationRequested) {
							x("returning early - cts1 cancelled");
							return;
						}
						const K = new s.$Nzb(
								this.d,
								s.CodeEditorStateFlag.Position | s.CodeEditorStateFlag.Value,
								G.range,
								this.c.token,
							),
							J = this.d.getModel(),
							W = this.n.newSymbolNamesProvider.all(J),
							X = await Promise.all(
								W.map(async (_) => [
									_,
									(await _.supportsAutomaticNewSymbolNamesTriggerKind) ?? !1,
								]),
							),
							Y = (_, te) => {
								let Q = X.slice();
								return (
									_ === o.NewSymbolNameTriggerKind.Automatic &&
										(Q = Q.filter(([Z, se]) => se)),
									Q.map(([Z]) => Z.provideNewSymbolNames(J, G.range, _, te))
								);
							};
						x("creating rename input field and awaiting its result");
						const ie =
								this.h.hasPreviewHandler() &&
								this.m.getValue(
									this.d.getModel().uri,
									"editor.rename.enablePreview",
								),
							ne = await this.a.getInput(
								G.range,
								G.text,
								ie,
								W.length > 0 ? Y : void 0,
								K,
							);
						if (
							(x("received response from rename input field"),
							W.length > 0 && this.q(W.length, J.getLanguageId(), ne),
							typeof ne == "boolean")
						) {
							x(`returning early - rename input field response - ${ne}`),
								ne && this.d.focus(),
								K.dispose();
							return;
						}
						this.d.focus(), x("requesting rename edits");
						const ee = (0, i.$Ah)(
							q.provideRenameEdits(ne.newName, K.token),
							K.token,
						)
							.then(
								async (_) => {
									if (!_) {
										x("returning early - no rename edits result");
										return;
									}
									if (!this.d.hasModel()) {
										x(
											"returning early - no model after rename edits are provided",
										);
										return;
									}
									if (_.rejectReason) {
										x(
											`returning early - rejected with reason: ${_.rejectReason}`,
										),
											this.g.info(_.rejectReason);
										return;
									}
									this.d.setSelection(
										g.$iL.fromPositions(this.d.getSelection().getPosition()),
									),
										x("applying edits"),
										this.h
											.apply(_, {
												editor: this.d,
												showPreview: ne.wantsPreview,
												label: y.localize(1404, null, G?.text, ne.newName),
												code: "undoredo.rename",
												quotableLabel: y.localize(
													1405,
													null,
													G?.text,
													ne.newName,
												),
												respectAutoSaveConfig: !0,
											})
											.then((te) => {
												x("edits applied"),
													te.ariaSummary &&
														(0, t.$oib)(
															y.localize(
																1406,
																null,
																G.text,
																ne.newName,
																te.ariaSummary,
															),
														);
											})
											.catch((te) => {
												x(
													`error when applying edits ${JSON.stringify(te, null, "	")}`,
												),
													this.g.error(y.localize(1407, null)),
													this.l.error(te);
											});
								},
								(_) => {
									x(
										"error when providing rename edits",
										JSON.stringify(_, null, "	"),
									),
										this.g.error(y.localize(1408, null)),
										this.l.error(_);
								},
							)
							.finally(() => {
								K.dispose();
							});
						return (
							x("returning rename operation"), this.j.showWhile(ee, 250), ee
						);
					}
					acceptRenameInput(x) {
						this.a.acceptInput(x);
					}
					cancelRenameInput() {
						this.a.cancelInput(!0, "cancelRenameInput command");
					}
					focusNextRenameSuggestion() {
						this.a.focusNextRenameSuggestion();
					}
					focusPreviousRenameSuggestion() {
						this.a.focusPreviousRenameSuggestion();
					}
					q(x, H, q) {
						const V =
							typeof q == "boolean"
								? {
										kind: "cancelled",
										languageId: H,
										nRenameSuggestionProviders: x,
									}
								: {
										kind: "accepted",
										languageId: H,
										nRenameSuggestionProviders: x,
										source: q.stats.source.k,
										nRenameSuggestions: q.stats.nRenameSuggestions,
										timeBeforeFirstInputFieldEdit:
											q.stats.timeBeforeFirstInputFieldEdit,
										wantsPreview: q.wantsPreview,
										nRenameSuggestionsInvocations:
											q.stats.nRenameSuggestionsInvocations,
										hadAutomaticRenameSuggestionsInvocation:
											q.stats.hadAutomaticRenameSuggestionsInvocation,
									};
						this.o.publicLog2("renameInvokedEvent", V);
					}
				};
				B = A = Ne(
					[
						j(1, I.$Li),
						j(2, k.$4N),
						j(3, h.$rzb),
						j(4, L.$bO),
						j(5, P.$ik),
						j(6, b.$XO),
						j(7, f.$k3),
						j(8, M.$km),
					],
					B,
				);
				class U extends a.$itb {
					constructor() {
						super({
							id: "editor.action.rename",
							label: y.localize(1409, null),
							alias: "Rename Symbol",
							precondition: S.$Kj.and(
								p.EditorContextKeys.writable,
								p.EditorContextKeys.hasRenameProvider,
							),
							kbOpts: {
								kbExpr: p.EditorContextKeys.editorTextFocus,
								primary: d.KeyCode.F2,
								weight: T.KeybindingWeight.EditorContrib,
							},
							contextMenuOpts: { group: "1_modification", order: 1.1 },
						});
					}
					runCommand(x, H) {
						const q = x.get(c.$dtb),
							[V, G] = (Array.isArray(H) && H) || [void 0, void 0];
						return u.URI.isUri(V) && n.$hL.isIPosition(G)
							? q
									.openCodeEditor({ resource: V }, q.getActiveCodeEditor())
									.then((K) => {
										K &&
											(K.setPosition(G),
											K.invokeWithinContext(
												(J) => (this.w(J, K), this.run(J, K)),
											));
									}, E.$4)
							: super.runCommand(x, H);
					}
					run(x, H) {
						const q = x.get(P.$ik),
							V = B.get(H);
						return V
							? (q.trace("[RenameAction] got controller, running..."), V.run())
							: (q.trace("[RenameAction] returning early - controller missing"),
								Promise.resolve());
					}
				}
				(e.$ekc = U),
					(0, a.$qtb)(B.ID, B, a.EditorContributionInstantiation.Lazy),
					(0, a.$ntb)(U);
				const z = a.$htb.bindToContribution(B.get);
				(0, a.$mtb)(
					new z({
						id: "acceptRenameInput",
						precondition: N.$akc,
						handler: (F) => F.acceptRenameInput(!1),
						kbOpts: {
							weight: T.KeybindingWeight.EditorContrib + 99,
							kbExpr: S.$Kj.and(
								p.EditorContextKeys.focus,
								S.$Kj.not("isComposing"),
							),
							primary: d.KeyCode.Enter,
						},
					}),
				),
					(0, a.$mtb)(
						new z({
							id: "acceptRenameInputWithPreview",
							precondition: S.$Kj.and(
								N.$akc,
								S.$Kj.has("config.editor.rename.enablePreview"),
							),
							handler: (F) => F.acceptRenameInput(!0),
							kbOpts: {
								weight: T.KeybindingWeight.EditorContrib + 99,
								kbExpr: S.$Kj.and(
									p.EditorContextKeys.focus,
									S.$Kj.not("isComposing"),
								),
								primary: d.KeyMod.CtrlCmd + d.KeyCode.Enter,
							},
						}),
					),
					(0, a.$mtb)(
						new z({
							id: "cancelRenameInput",
							precondition: N.$akc,
							handler: (F) => F.cancelRenameInput(),
							kbOpts: {
								weight: T.KeybindingWeight.EditorContrib + 99,
								kbExpr: p.EditorContextKeys.focus,
								primary: d.KeyCode.Escape,
								secondary: [d.KeyMod.Shift | d.KeyCode.Escape],
							},
						}),
					),
					(0, $.$4X)(
						class extends $.$3X {
							constructor() {
								super({
									id: "focusNextRenameSuggestion",
									title: {
										...y.localize2(1411, "Focus Next Rename Suggestion"),
									},
									precondition: N.$akc,
									keybinding: [
										{
											primary: d.KeyCode.DownArrow,
											weight: T.KeybindingWeight.EditorContrib + 99,
										},
									],
								});
							}
							run(x) {
								const H = x.get(c.$dtb).getFocusedCodeEditor();
								if (!H) return;
								const q = B.get(H);
								q && q.focusNextRenameSuggestion();
							}
						},
					),
					(0, $.$4X)(
						class extends $.$3X {
							constructor() {
								super({
									id: "focusPreviousRenameSuggestion",
									title: {
										...y.localize2(1412, "Focus Previous Rename Suggestion"),
									},
									precondition: N.$akc,
									keybinding: [
										{
											primary: d.KeyCode.UpArrow,
											weight: T.KeybindingWeight.EditorContrib + 99,
										},
									],
								});
							}
							run(x) {
								const H = x.get(c.$dtb).getFocusedCodeEditor();
								if (!H) return;
								const q = B.get(H);
								q && q.focusPreviousRenameSuggestion();
							}
						},
					),
					(0, a.$ltb)(
						"_executeDocumentRenameProvider",
						function (F, x, H, ...q) {
							const [V] = q;
							(0, r.$vg)(typeof V == "string");
							const { renameProvider: G } = F.get(f.$k3);
							return O(G, x, H, V);
						},
					),
					(0, a.$ltb)("_executePrepareRename", async function (F, x, H) {
						const { renameProvider: q } = F.get(f.$k3),
							G = await new R(x, H, q).resolveRenameLocation(
								w.CancellationToken.None,
							);
						if (G?.rejectReason) throw new Error(G.rejectReason);
						return G;
					}),
					D.$Io
						.as(v.$No.Configuration)
						.registerConfiguration({
							id: "editor",
							properties: {
								"editor.rename.enablePreview": {
									scope: v.ConfigurationScope.LANGUAGE_OVERRIDABLE,
									description: y.localize(1410, null),
									default: !0,
									type: "boolean",
								},
							},
						});
			},
		),
		define(
			de[2864],
			he([
				1, 0, 3, 29, 67, 10, 15, 33, 35, 1209, 1602, 391, 162, 69, 1180, 588,
				1156,
			]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a, h, c, n, g, p) {
				"use strict";
				var o;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$gkc = void 0),
					(i = mt(i));
				let f = class extends t.$1c {
					constructor(y, $, v, S, I, T) {
						super(), (this.a = Object.create(null));
						const P = (D) => {
								this.a[D.uri.toString()] = new b(D, y, v, I, T);
							},
							k = (D, M) => {
								M.dispose(), delete this.a[D.uri.toString()];
							},
							L = () => {
								for (const D of $.getModels()) {
									const M = this.a[D.uri.toString()];
									(0, p.$ePb)(D, v, S) ? M || P(D) : M && k(D, M);
								}
							};
						$.getModels().forEach((D) => {
							(0, p.$ePb)(D, v, S) && P(D);
						}),
							this.D(
								$.onModelAdded((D) => {
									(0, p.$ePb)(D, v, S) && P(D);
								}),
							),
							this.D(
								$.onModelRemoved((D) => {
									const M = this.a[D.uri.toString()];
									M && k(D, M);
								}),
							),
							this.D(
								S.onDidChangeConfiguration((D) => {
									D.affectsConfiguration(p.$dPb) && L();
								}),
							),
							this.D(v.onDidColorThemeChange(L));
					}
					dispose() {
						for (const y of Object.values(this.a)) y.dispose();
						super.dispose();
					}
				};
				(e.$gkc = f),
					(e.$gkc = f =
						Ne(
							[
								j(0, n.$hPb),
								j(1, w.$QO),
								j(2, m.$iP),
								j(3, E.$gj),
								j(4, a.$PBb),
								j(5, c.$k3),
							],
							f,
						));
				let b = class extends t.$1c {
					static {
						o = this;
					}
					static {
						this.REQUEST_MIN_DELAY = 300;
					}
					static {
						this.REQUEST_MAX_DELAY = 2e3;
					}
					constructor(y, $, v, S, I) {
						super(),
							(this.q = $),
							(this.a = !1),
							(this.b = y),
							(this.c = I.documentSemanticTokensProvider),
							(this.f = S.for(this.c, "DocumentSemanticTokens", {
								min: o.REQUEST_MIN_DELAY,
								max: o.REQUEST_MAX_DELAY,
							})),
							(this.g = this.D(new C.$Yh(() => this.r(), o.REQUEST_MIN_DELAY))),
							(this.h = null),
							(this.j = null),
							(this.m = []),
							(this.n = !1),
							this.D(
								this.b.onDidChangeContent(() => {
									this.g.isScheduled() || this.g.schedule(this.f.get(this.b));
								}),
							),
							this.D(
								this.b.onDidChangeAttached(() => {
									this.g.isScheduled() || this.g.schedule(this.f.get(this.b));
								}),
							),
							this.D(
								this.b.onDidChangeLanguage(() => {
									this.h && (this.h.dispose(), (this.h = null)),
										this.j && (this.j.cancel(), (this.j = null)),
										this.t(null, null, null, []),
										this.g.schedule(0);
								}),
							);
						const T = () => {
							(0, t.$Vc)(this.m), (this.m = []);
							for (const P of this.c.all(y))
								typeof P.onDidChange == "function" &&
									this.m.push(
										P.onDidChange(() => {
											if (this.j) {
												this.n = !0;
												return;
											}
											this.g.schedule(0);
										}),
									);
						};
						T(),
							this.D(
								this.c.onDidChange(() => {
									T(), this.g.schedule(this.f.get(this.b));
								}),
							),
							this.D(
								v.onDidColorThemeChange((P) => {
									this.t(null, null, null, []),
										this.g.schedule(this.f.get(this.b));
								}),
							),
							this.g.schedule(0);
					}
					dispose() {
						this.h && (this.h.dispose(), (this.h = null)),
							this.j && (this.j.cancel(), (this.j = null)),
							(0, t.$Vc)(this.m),
							(this.m = []),
							this.t(null, null, null, []),
							(this.a = !0),
							super.dispose();
					}
					r() {
						if (this.j) return;
						if (!(0, u.$_Ob)(this.c, this.b)) {
							this.h && this.b.tokenization.setSemanticTokens(null, !1);
							return;
						}
						if (!this.b.isAttachedToEditor()) return;
						const y = new d.$Ce(),
							$ = this.h ? this.h.provider : null,
							v = (this.h && this.h.resultId) || null,
							S = (0, u.$aPb)(this.c, this.b, $, v, y.token);
						(this.j = y), (this.n = !1);
						const I = [],
							T = this.b.onDidChangeContent((k) => {
								I.push(k);
							}),
							P = new h.$le(!1);
						S.then(
							(k) => {
								if (
									(this.f.update(this.b, P.elapsed()),
									(this.j = null),
									T.dispose(),
									!k)
								)
									this.t(null, null, null, I);
								else {
									const { provider: L, tokens: D } = k,
										M = this.q.getStyling(L);
									this.t(L, D || null, M, I);
								}
							},
							(k) => {
								(k &&
									(i.$8(k) ||
										(typeof k.message == "string" &&
											k.message.indexOf("busy") !== -1))) ||
									i.$4(k),
									(this.j = null),
									T.dispose(),
									(I.length > 0 || this.n) &&
										(this.g.isScheduled() ||
											this.g.schedule(this.f.get(this.b)));
							},
						);
					}
					static s(y, $, v, S, I) {
						I = Math.min(I, v.length - S, y.length - $);
						for (let T = 0; T < I; T++) v[S + T] = y[$ + T];
					}
					t(y, $, v, S) {
						const I = this.h,
							T = () => {
								(S.length > 0 || this.n) &&
									!this.g.isScheduled() &&
									this.g.schedule(this.f.get(this.b));
							};
						if ((this.h && (this.h.dispose(), (this.h = null)), this.a)) {
							y && $ && y.releaseDocumentSemanticTokens($.resultId);
							return;
						}
						if (!y || !v) {
							this.b.tokenization.setSemanticTokens(null, !1);
							return;
						}
						if (!$) {
							this.b.tokenization.setSemanticTokens(null, !0), T();
							return;
						}
						if ((0, u.$0Ob)($)) {
							if (!I) {
								this.b.tokenization.setSemanticTokens(null, !0);
								return;
							}
							if ($.edits.length === 0)
								$ = { resultId: $.resultId, data: I.data };
							else {
								let P = 0;
								for (const N of $.edits)
									P += (N.data ? N.data.length : 0) - N.deleteCount;
								const k = I.data,
									L = new Uint32Array(k.length + P);
								let D = k.length,
									M = L.length;
								for (let N = $.edits.length - 1; N >= 0; N--) {
									const A = $.edits[N];
									if (A.start > k.length) {
										v.warnInvalidEditStart(
											I.resultId,
											$.resultId,
											N,
											A.start,
											k.length,
										),
											this.b.tokenization.setSemanticTokens(null, !0);
										return;
									}
									const R = D - (A.start + A.deleteCount);
									R > 0 && (o.s(k, D - R, L, M - R, R), (M -= R)),
										A.data &&
											(o.s(A.data, 0, L, M - A.data.length, A.data.length),
											(M -= A.data.length)),
										(D = A.start);
								}
								D > 0 && o.s(k, 0, L, 0, D),
									($ = { resultId: $.resultId, data: L });
							}
						}
						if ((0, u.$9Ob)($)) {
							this.h = new s(y, $.resultId, $.data);
							const P = (0, r.$gPb)($, v, this.b.getLanguageId());
							if (S.length > 0)
								for (const k of S)
									for (const L of P)
										for (const D of k.changes) L.applyEdit(D.range, D.text);
							this.b.tokenization.setSemanticTokens(P, !0);
						} else this.b.tokenization.setSemanticTokens(null, !0);
						T();
					}
				};
				b = o = Ne([j(1, n.$hPb), j(2, m.$iP), j(3, a.$PBb), j(4, c.$k3)], b);
				class s {
					constructor(y, $, v) {
						(this.provider = y), (this.resultId = $), (this.data = v);
					}
					dispose() {
						this.provider.releaseDocumentSemanticTokens(this.resultId);
					}
				}
				(0, g.$SBb)(f);
			},
		),
		define(
			de[956],
			he([1, 0, 15, 3, 46, 1602, 1156, 1209, 10, 35, 391, 162, 69, 1180]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a, h, c) {
				"use strict";
				var n;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$iPb = void 0);
				let g = class extends i.$1c {
					static {
						n = this;
					}
					static {
						this.ID = "editor.contrib.viewportSemanticTokens";
					}
					static get(o) {
						return o.getContribution(n.ID);
					}
					constructor(o, f, b, s, l, y) {
						super(),
							(this.h = f),
							(this.j = b),
							(this.m = s),
							(this.a = o),
							(this.b = y.documentRangeSemanticTokensProvider),
							(this.c = l.for(this.b, "DocumentRangeSemanticTokens", {
								min: 100,
								max: 500,
							})),
							(this.f = this.D(new t.$Yh(() => this.s(), 100))),
							(this.g = []);
						const $ = () => {
							this.a.hasModel() &&
								this.f.schedule(this.c.get(this.a.getModel()));
						};
						this.D(
							this.a.onDidScrollChange(() => {
								$();
							}),
						),
							this.D(
								this.a.onDidChangeModel(() => {
									this.n(), $();
								}),
							),
							this.D(
								this.a.onDidChangeModelContent((v) => {
									this.n(), $();
								}),
							),
							this.D(
								this.b.onDidChange(() => {
									this.n(), $();
								}),
							),
							this.D(
								this.m.onDidChangeConfiguration((v) => {
									v.affectsConfiguration(C.$dPb) && (this.n(), $());
								}),
							),
							this.D(
								this.j.onDidColorThemeChange(() => {
									this.n(), $();
								}),
							),
							$();
					}
					n() {
						for (const o of this.g) o.cancel();
						this.g = [];
					}
					q(o) {
						for (let f = 0, b = this.g.length; f < b; f++)
							if (this.g[f] === o) {
								this.g.splice(f, 1);
								return;
							}
					}
					s() {
						if (!this.a.hasModel()) return;
						const o = this.a.getModel();
						if (o.tokenization.hasCompleteSemanticTokens()) return;
						if (!(0, C.$ePb)(o, this.j, this.m)) {
							o.tokenization.hasSomeSemanticTokens() &&
								o.tokenization.setSemanticTokens(null, !1);
							return;
						}
						if (!(0, E.$bPb)(this.b, o)) {
							o.tokenization.hasSomeSemanticTokens() &&
								o.tokenization.setSemanticTokens(null, !1);
							return;
						}
						const f = this.a.getVisibleRangesPlusViewportAboveBelow();
						this.g = this.g.concat(f.map((b) => this.t(o, b)));
					}
					t(o, f) {
						const b = o.getVersionId(),
							s = (0, t.$zh)((y) =>
								Promise.resolve((0, E.$cPb)(this.b, o, f, y)),
							),
							l = new a.$le(!1);
						return (
							s
								.then((y) => {
									if (
										(this.c.update(o, l.elapsed()),
										!y || !y.tokens || o.isDisposed() || o.getVersionId() !== b)
									)
										return;
									const { provider: $, tokens: v } = y,
										S = this.h.getStyling($);
									o.tokenization.setPartialSemanticTokens(
										f,
										(0, d.$gPb)(v, S, o.getLanguageId()),
									);
								})
								.then(
									() => this.q(s),
									() => this.q(s),
								),
							s
						);
					}
				};
				(e.$iPb = g),
					(e.$iPb =
						g =
						n =
							Ne(
								[
									j(1, c.$hPb),
									j(2, r.$iP),
									j(3, m.$gj),
									j(4, u.$PBb),
									j(5, h.$k3),
								],
								g,
							)),
					(0, w.$qtb)(
						g.ID,
						g,
						w.EditorContributionInstantiation.AfterFirstRender,
					);
			},
		),
		define(
			de[2865],
			he([
				1, 0, 7, 325, 14, 26, 6, 132, 3, 9, 38, 74, 252, 67, 61, 4, 22, 79, 35,
				1633,
			]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a, h, c, n, g, p, o, f, b) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$EDb = void 0),
					(e.$DDb = s),
					(g = mt(g));
				function s(S) {
					return `suggest-aria-id:${S}`;
				}
				const l = (0, o.$$O)(
						"suggest-more-info",
						w.$ak.chevronRight,
						g.localize(1513, null),
					),
					y = new (class ea {
						static {
							this.a =
								/(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/;
						}
						static {
							this.b = new RegExp(`^${ea.a.source}$`, "i");
						}
						extract(I, T) {
							if (I.textLabel.match(ea.b)) return (T[0] = I.textLabel), !0;
							if (I.completion.detail && I.completion.detail.match(ea.b))
								return (T[0] = I.completion.detail), !0;
							if (I.completion.documentation) {
								const P =
										typeof I.completion.documentation == "string"
											? I.completion.documentation
											: I.completion.documentation.value,
									k = ea.a.exec(P);
								if (k && (k.index === 0 || k.index + k[0].length === P.length))
									return (T[0] = k[0]), !0;
							}
							return !1;
						}
					})();
				let $ = class {
					constructor(I, T, P, k) {
						(this.b = I),
							(this.c = T),
							(this.d = P),
							(this.f = k),
							(this.a = new C.$re()),
							(this.onDidToggleDetails = this.a.event),
							(this.templateId = "suggestion");
					}
					dispose() {
						this.a.dispose();
					}
					renderTemplate(I) {
						const T = new m.$Zc(),
							P = I;
						P.classList.add("show-file-icons");
						const k = (0, t.$fhb)(I, (0, t.$)(".icon")),
							L = (0, t.$fhb)(k, (0, t.$)("span.colorspan")),
							D = (0, t.$fhb)(I, (0, t.$)(".contents")),
							M = (0, t.$fhb)(D, (0, t.$)(".main")),
							N = (0, t.$fhb)(M, (0, t.$)(".icon-label.codicon")),
							A = (0, t.$fhb)(M, (0, t.$)("span.left")),
							R = (0, t.$fhb)(M, (0, t.$)("span.right")),
							O = new i.$Xob(A, { supportHighlights: !0, supportIcons: !0 });
						T.add(O);
						const B = (0, t.$fhb)(A, (0, t.$)("span.signature-label")),
							U = (0, t.$fhb)(A, (0, t.$)("span.qualifier-label")),
							z = (0, t.$fhb)(R, (0, t.$)("span.details-label")),
							F = (0, t.$fhb)(
								R,
								(0, t.$)("span.readMore" + E.ThemeIcon.asCSSSelector(l)),
							);
						return (
							(F.title = g.localize(1514, null)),
							{
								root: P,
								left: A,
								right: R,
								icon: k,
								colorspan: L,
								iconLabel: O,
								iconContainer: N,
								parametersLabel: B,
								qualifierLabel: U,
								detailsLabel: z,
								readMore: F,
								disposables: T,
								configureFont: () => {
									const H = this.b.getOptions(),
										q = H.get(u.EditorOption.fontInfo),
										V = q.getMassagedFontFamily(),
										G = q.fontFeatureSettings,
										K = H.get(u.EditorOption.suggestFontSize) || q.fontSize,
										J = H.get(u.EditorOption.suggestLineHeight) || q.lineHeight,
										W = q.fontWeight,
										X = q.letterSpacing,
										Y = `${K}px`,
										ie = `${J}px`,
										ne = `${X}px`;
									(P.style.fontSize = Y),
										(P.style.fontWeight = W),
										(P.style.letterSpacing = ne),
										(M.style.fontFamily = V),
										(M.style.fontFeatureSettings = G),
										(M.style.lineHeight = ie),
										(k.style.height = ie),
										(k.style.width = ie),
										(F.style.height = ie),
										(F.style.width = ie);
								},
							}
						);
					}
					renderElement(I, T, P) {
						P.configureFont();
						const { completion: k } = I;
						(P.root.id = s(T)), (P.colorspan.style.backgroundColor = "");
						const L = { labelEscapeNewLines: !0, matches: (0, d.$3k)(I.score) },
							D = [];
						if (k.kind === a.CompletionItemKind.Color && y.extract(I, D))
							(P.icon.className = "icon customcolor"),
								(P.iconContainer.className = "icon hide"),
								(P.colorspan.style.backgroundColor = D[0]);
						else if (
							k.kind === a.CompletionItemKind.File &&
							this.f.getFileIconTheme().hasFileIcons
						) {
							(P.icon.className = "icon hide"),
								(P.iconContainer.className = "icon hide");
							const M = (0, h.$BDb)(
									this.c,
									this.d,
									r.URI.from({ scheme: "fake", path: I.textLabel }),
									p.FileKind.FILE,
								),
								N = (0, h.$BDb)(
									this.c,
									this.d,
									r.URI.from({ scheme: "fake", path: k.detail }),
									p.FileKind.FILE,
								);
							L.extraClasses = M.length > N.length ? M : N;
						} else
							k.kind === a.CompletionItemKind.Folder &&
							this.f.getFileIconTheme().hasFolderIcons
								? ((P.icon.className = "icon hide"),
									(P.iconContainer.className = "icon hide"),
									(L.extraClasses = [
										(0, h.$BDb)(
											this.c,
											this.d,
											r.URI.from({ scheme: "fake", path: I.textLabel }),
											p.FileKind.FOLDER,
										),
										(0, h.$BDb)(
											this.c,
											this.d,
											r.URI.from({ scheme: "fake", path: k.detail }),
											p.FileKind.FOLDER,
										),
									].flat()))
								: ((P.icon.className = "icon hide"),
									(P.iconContainer.className = ""),
									P.iconContainer.classList.add(
										"suggest-icon",
										...E.ThemeIcon.asClassNameArray(
											a.CompletionItemKinds.toIcon(k.kind),
										),
									));
						k.tags &&
							k.tags.indexOf(a.CompletionItemTag.Deprecated) >= 0 &&
							((L.extraClasses = (L.extraClasses || []).concat(["deprecated"])),
							(L.matches = [])),
							P.iconLabel.setLabel(I.textLabel, void 0, L),
							typeof k.label == "string"
								? ((P.parametersLabel.textContent = ""),
									(P.detailsLabel.textContent = v(k.detail || "")),
									P.root.classList.add("string-label"))
								: ((P.parametersLabel.textContent = v(k.label.detail || "")),
									(P.detailsLabel.textContent = v(k.label.description || "")),
									P.root.classList.remove("string-label")),
							this.b.getOption(u.EditorOption.suggest).showInlineDetails
								? (0, t.show)(P.detailsLabel)
								: (0, t.hide)(P.detailsLabel),
							(0, b.$yDb)(I)
								? (P.right.classList.add("can-expand-details"),
									(0, t.show)(P.readMore),
									(P.readMore.onmousedown = (M) => {
										M.stopPropagation(), M.preventDefault();
									}),
									(P.readMore.onclick = (M) => {
										M.stopPropagation(), M.preventDefault(), this.a.fire();
									}))
								: (P.right.classList.remove("can-expand-details"),
									(0, t.hide)(P.readMore),
									(P.readMore.onmousedown = null),
									(P.readMore.onclick = null));
					}
					disposeTemplate(I) {
						I.disposables.dispose();
					}
				};
				(e.$EDb = $),
					(e.$EDb = $ = Ne([j(1, c.$QO), j(2, n.$nM), j(3, f.$iP)], $));
				function v(S) {
					return S.replace(/\r\n|\r|\n/g, "");
				}
			},
		),
		define(
			de[2866],
			he([
				1, 0, 7, 6, 264, 4, 5, 93, 35, 3, 63, 114, 27, 12, 138, 325, 460, 105,
				212, 9, 1625, 149, 274, 160, 535, 37, 411, 15, 29, 91, 77, 24,
			]),
			function (
				ce,
				e,
				t,
				i,
				w,
				E,
				C,
				d,
				m,
				r,
				u,
				a,
				h,
				c,
				n,
				g,
				p,
				o,
				f,
				b,
				s,
				l,
				y,
				$,
				v,
				S,
				I,
				T,
				P,
				k,
				L,
				D,
			) {
				"use strict";
				var M;
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$uxc = void 0),
					(t = mt(t));
				const N = t.$;
				class A {
					constructor(W, X, Y) {
						(this.index = W),
							(this.hasCheckbox = X),
							(this.c = !1),
							(this.a = new l.$Y(() => {
								const ie = Y.label ?? "",
									ne = (0, y.$al)(ie).text.trim(),
									ee =
										Y.ariaLabel ||
										[ie, this.saneDescription, this.saneDetail]
											.map((_) => (0, y.$_k)(_))
											.filter((_) => !!_)
											.join(", ");
								return { saneLabel: ie, saneSortLabel: ne, saneAriaLabel: ee };
							})),
							(this.d = Y.description),
							(this.h = Y.tooltip);
					}
					get saneLabel() {
						return this.a.value.saneLabel;
					}
					get saneSortLabel() {
						return this.a.value.saneSortLabel;
					}
					get saneAriaLabel() {
						return this.a.value.saneAriaLabel;
					}
					get element() {
						return this.b;
					}
					set element(W) {
						this.b = W;
					}
					get hidden() {
						return this.c;
					}
					set hidden(W) {
						this.c = W;
					}
					get saneDescription() {
						return this.d;
					}
					set saneDescription(W) {
						this.d = W;
					}
					get saneDetail() {
						return this.f;
					}
					set saneDetail(W) {
						this.f = W;
					}
					get saneBreadcrumbPath() {
						return this.g;
					}
					set saneBreadcrumbPath(W) {
						this.g = W;
					}
					get saneTooltip() {
						return this.h;
					}
					set saneTooltip(W) {
						this.h = W;
					}
					get labelHighlights() {
						return this.j;
					}
					set labelHighlights(W) {
						this.j = W;
					}
					get descriptionHighlights() {
						return this.k;
					}
					set descriptionHighlights(W) {
						this.k = W;
					}
					get detailHighlights() {
						return this.l;
					}
					set detailHighlights(W) {
						this.l = W;
					}
				}
				class R extends A {
					constructor(W, X, Y, ie, ne, ee) {
						super(W, X, ne),
							(this.fireButtonTriggered = Y),
							(this.m = ie),
							(this.item = ne),
							(this.o = ee),
							(this.p = !1),
							(this.onChecked = X
								? i.Event.map(
										i.Event.filter(this.m.event, (_) => _.element === this),
										(_) => _.checked,
									)
								: i.Event.None),
							(this.f = ne.detail),
							(this.g = ne.semSearchData?.outlineBreadcrumbs),
							(this.j = ne.highlights?.label),
							(this.k = ne.highlights?.description),
							(this.l = ne.highlights?.detail);
					}
					get separator() {
						return this.o;
					}
					set separator(W) {
						this.o = W;
					}
					get checked() {
						return this.p;
					}
					set checked(W) {
						W !== this.p &&
							((this.p = W), this.m.fire({ element: this, checked: W }));
					}
					get checkboxDisabled() {
						return !!this.item.disabled;
					}
				}
				var O;
				(function (J) {
					(J[(J.NONE = 0)] = "NONE"),
						(J[(J.MOUSE_HOVER = 1)] = "MOUSE_HOVER"),
						(J[(J.ACTIVE_ITEM = 2)] = "ACTIVE_ITEM");
				})(O || (O = {}));
				class B extends A {
					constructor(W, X, Y) {
						super(W, !1, Y),
							(this.fireSeparatorButtonTriggered = X),
							(this.separator = Y),
							(this.children = new Array()),
							(this.focusInsideSeparator = O.NONE);
					}
				}
				class U {
					getHeight(W) {
						return W instanceof B
							? 30
							: W.saneDetail || W.saneBreadcrumbPath
								? 44
								: 22;
					}
					getTemplateId(W) {
						return W instanceof R ? x.ID : H.ID;
					}
				}
				class z {
					getWidgetAriaLabel() {
						return (0, E.localize)(2058, null);
					}
					getAriaLabel(W) {
						return W.separator?.label
							? `${W.saneAriaLabel}, ${W.separator.label}`
							: W.saneAriaLabel;
					}
					getWidgetRole() {
						return "listbox";
					}
					getRole(W) {
						return W.hasCheckbox ? "checkbox" : "option";
					}
					isChecked(W) {
						if (!(!W.hasCheckbox || !(W instanceof R)))
							return {
								get value() {
									return W.checked;
								},
								onDidChange: (X) => W.onChecked(() => X()),
							};
					}
				}
				class F {
					constructor(W) {
						this.a = W;
					}
					renderTemplate(W) {
						const X = Object.create(null);
						(X.toDisposeElement = new r.$Zc()),
							(X.toDisposeTemplate = new r.$Zc()),
							(X.entry = t.$fhb(W, N(".quick-input-list-entry")));
						const Y = t.$fhb(X.entry, N("label.quick-input-list-label"));
						X.toDisposeTemplate.add(
							t.$$fb(Y, t.$$gb.CLICK, (se) => {
								X.checkbox.offsetParent || se.preventDefault();
							}),
						),
							(X.checkbox = t.$fhb(Y, N("input.quick-input-list-checkbox"))),
							(X.checkbox.type = "checkbox");
						const ie = t.$fhb(Y, N(".quick-input-list-rows")),
							ne = t.$fhb(ie, N(".quick-input-list-row")),
							ee = t.$fhb(ie, N(".quick-input-list-row")),
							_ = t.$fhb(ie, N(".quick-input-list-row"));
						(X.label = new g.$Xob(ne, {
							supportHighlights: !0,
							supportDescriptionHighlights: !0,
							supportIcons: !0,
							hoverDelegate: this.a,
						})),
							X.toDisposeTemplate.add(X.label),
							(X.icon = t.$ghb(X.label.element, N(".quick-input-list-icon")));
						const te = t.$fhb(ne, N(".quick-input-list-entry-keybinding"));
						(X.keybinding = new p.$7ob(te, c.OS)),
							X.toDisposeTemplate.add(X.keybinding);
						const Q = t.$fhb(ee, N(".quick-input-list-label-meta"));
						(X.detail = new g.$Xob(Q, {
							supportHighlights: !0,
							supportIcons: !0,
							hoverDelegate: this.a,
						})),
							X.toDisposeTemplate.add(X.detail);
						const Z = t.$fhb(_, N(".quick-input-list-outline-breadcrumbs"));
						return (
							(X.outlineBreadcrumbs = Z),
							X.toDisposeTemplate.add({
								dispose: () => {
									t.$9fb(X.outlineBreadcrumbs), X.outlineBreadcrumbs.remove();
								},
							}),
							(X.separator = t.$fhb(X.entry, N(".quick-input-list-separator"))),
							(X.actionBar = new o.$eib(
								X.entry,
								this.a ? { hoverDelegate: this.a } : void 0,
							)),
							X.actionBar.domNode.classList.add(
								"quick-input-list-entry-action-bar",
							),
							X.toDisposeTemplate.add(X.actionBar),
							X
						);
					}
					disposeTemplate(W) {
						W.toDisposeElement.dispose(), W.toDisposeTemplate.dispose();
					}
					disposeElement(W, X, Y) {
						Y.toDisposeElement.clear(), Y.actionBar.clear();
					}
				}
				let x = class extends F {
					static {
						M = this;
					}
					static {
						this.ID = "quickpickitem";
					}
					constructor(W, X) {
						super(W), (this.c = X), (this.b = new Map());
					}
					get templateId() {
						return M.ID;
					}
					renderTemplate(W) {
						const X = super.renderTemplate(W);
						return (
							X.toDisposeTemplate.add(
								t.$$fb(X.checkbox, t.$$gb.CHANGE, (Y) => {
									X.element.checked = X.checkbox.checked;
								}),
							),
							X
						);
					}
					renderElement(W, X, Y) {
						const ie = W.element;
						(Y.element = ie), (ie.element = Y.entry ?? void 0);
						const ne = ie.item;
						(Y.checkbox.checked = ie.checked),
							Y.toDisposeElement.add(
								ie.onChecked((re) => (Y.checkbox.checked = re)),
							),
							(Y.checkbox.disabled = ie.checkboxDisabled);
						const {
							labelHighlights: ee,
							descriptionHighlights: _,
							detailHighlights: te,
						} = ie;
						if (ne.iconPath) {
							const re = (0, f.$hP)(this.c.getColorTheme().type)
									? ne.iconPath.dark
									: (ne.iconPath.light ?? ne.iconPath.dark),
								le = b.URI.revive(re);
							(Y.icon.className = "quick-input-list-icon"),
								(Y.icon.style.backgroundImage = t.$vhb(le));
						} else
							(Y.icon.style.backgroundImage = ""),
								(Y.icon.className = ne.iconClass
									? `quick-input-list-icon ${ne.iconClass}`
									: "");
						let Q;
						!ie.saneTooltip &&
							ie.saneDescription &&
							(Q = {
								markdown: { value: ie.saneDescription, supportThemeIcons: !0 },
								markdownNotSupportedFallback: ie.saneDescription,
							});
						const Z = {
							matches: ee || [],
							descriptionTitle: Q,
							descriptionMatches: _ || [],
							labelEscapeNewLines: !0,
						};
						if (
							((Z.extraClasses = ne.iconClasses),
							(Z.italic = ne.italic),
							(Z.strikethrough = ne.strikethrough),
							Y.entry.classList.remove("quick-input-list-separator-as-item"),
							Y.label.setLabel(ie.saneLabel, ie.saneDescription, Z),
							Y.keybinding.set(ne.keybinding),
							ie.saneDetail)
						) {
							let re;
							ie.saneTooltip ||
								(re = {
									markdown: { value: ie.saneDetail, supportThemeIcons: !0 },
									markdownNotSupportedFallback: ie.saneDetail,
								}),
								(Y.detail.element.style.display = ""),
								Y.detail.setLabel(ie.saneDetail, void 0, {
									matches: te,
									title: re,
									labelEscapeNewLines: !0,
								});
						} else Y.detail.element.style.display = "none";
						this.g(ie, Y),
							ie.separator?.label
								? ((Y.separator.textContent = ie.separator.label),
									(Y.separator.style.display = ""),
									this.d(ie))
								: (Y.separator.style.display = "none"),
							Y.entry.classList.toggle(
								"quick-input-list-separator-border",
								!!ie.separator,
							);
						const se = ne.buttons;
						se && se.length
							? (Y.actionBar.push(
									se.map((re, le) =>
										(0, s.$sxc)(re, `id-${le}`, () =>
											ie.fireButtonTriggered({ button: re, item: ie.item }),
										),
									),
									{ icon: !0, label: !1 },
								),
								Y.entry.classList.add("has-actions"))
							: Y.entry.classList.remove("has-actions");
					}
					disposeElement(W, X, Y) {
						this.f(W.element), super.disposeElement(W, X, Y);
					}
					isItemWithSeparatorVisible(W) {
						return this.b.has(W);
					}
					d(W) {
						this.b.set(W, (this.b.get(W) || 0) + 1);
					}
					f(W) {
						const X = this.b.get(W) || 0;
						X > 1 ? this.b.set(W, X - 1) : this.b.delete(W);
					}
					g(W, X) {
						if (W.saneBreadcrumbPath) {
							t.$9fb(X.outlineBreadcrumbs),
								(X.outlineBreadcrumbs.style.display = "flex"),
								(X.outlineBreadcrumbs.style.alignItems = "center"),
								(X.outlineBreadcrumbs.style.fontSize = "12px"),
								(X.outlineBreadcrumbs.style.marginBottom = "4px"),
								(X.outlineBreadcrumbs.style.overflow = "hidden"),
								(X.outlineBreadcrumbs.style.whiteSpace = "nowrap"),
								(X.outlineBreadcrumbs.style.fontFamily =
									"var(--vscode-font-family)"),
								(X.outlineBreadcrumbs.style.width = "fit-content"),
								(X.outlineBreadcrumbs.style.paddingLeft = "1px"),
								(X.outlineBreadcrumbs.style.padding = "0px 10px");
							for (let Y = 0; Y < W.saneBreadcrumbPath.length; Y++) {
								const ie = W.saneBreadcrumbPath[Y],
									ne = Y === W.saneBreadcrumbPath.length - 1,
									ee = t.$fhb(X.outlineBreadcrumbs, N(".outline-item"));
								(ee.style.display = "inline-flex"),
									(ee.style.alignItems = "center"),
									(ee.style.justifyContent = "flex-end"),
									(ee.style.flexShrink = "0"),
									(ee.style.overflow = "hidden"),
									(ee.style.textOverflow = "ellipsis"),
									(ee.style.color = ne
										? "var(--vscode-editor-foreground)"
										: "var(--vscode-descriptionForeground)"),
									(ee.style.fontWeight = ne ? "500" : "normal"),
									(ee.style.cursor = "pointer"),
									(ee.style.padding = "0px 2px"),
									(ee.style.color = "auto");
								const _ = t.$fhb(ee, N(".icon"));
								(_.className = ie.className + " important"),
									(_.style.marginRight = "4px"),
									(_.style.fontSize = "14px");
								const te = t.$fhb(ee, N("span"));
								if (((te.textContent = ie.label), !ne)) {
									const Q = t.$fhb(X.outlineBreadcrumbs, N("span"));
									(Q.textContent = ">"),
										(Q.style.margin = "0 2px"),
										(Q.style.color = "var(--vscode-descriptionForeground)"),
										(Q.style.opacity = "0.6");
								}
							}
						} else X.outlineBreadcrumbs.style.display = "none";
					}
				};
				x = M = Ne([j(1, m.$iP)], x);
				class H extends F {
					constructor() {
						super(...arguments), (this.b = new Map());
					}
					static {
						this.ID = "quickpickseparator";
					}
					get templateId() {
						return H.ID;
					}
					get visibleSeparators() {
						return [...this.b.keys()];
					}
					isSeparatorVisible(W) {
						return this.b.has(W);
					}
					renderTemplate(W) {
						const X = super.renderTemplate(W);
						return (X.checkbox.style.display = "none"), X;
					}
					renderElement(W, X, Y) {
						const ie = W.element;
						(Y.element = ie),
							(ie.element = Y.entry ?? void 0),
							ie.element.classList.toggle(
								"focus-inside",
								!!ie.focusInsideSeparator,
							);
						const ne = ie.separator,
							{
								labelHighlights: ee,
								descriptionHighlights: _,
								detailHighlights: te,
							} = ie;
						(Y.icon.style.backgroundImage = ""), (Y.icon.className = "");
						let Q;
						!ie.saneTooltip &&
							ie.saneDescription &&
							(Q = {
								markdown: { value: ie.saneDescription, supportThemeIcons: !0 },
								markdownNotSupportedFallback: ie.saneDescription,
							});
						const Z = {
							matches: ee || [],
							descriptionTitle: Q,
							descriptionMatches: _ || [],
							labelEscapeNewLines: !0,
						};
						if (
							(Y.entry.classList.add("quick-input-list-separator-as-item"),
							Y.label.setLabel(ie.saneLabel, ie.saneDescription, Z),
							ie.saneDetail)
						) {
							let re;
							ie.saneTooltip ||
								(re = {
									markdown: { value: ie.saneDetail, supportThemeIcons: !0 },
									markdownNotSupportedFallback: ie.saneDetail,
								}),
								(Y.detail.element.style.display = ""),
								Y.detail.setLabel(ie.saneDetail, void 0, {
									matches: te,
									title: re,
									labelEscapeNewLines: !0,
								});
						} else Y.detail.element.style.display = "none";
						(Y.separator.style.display = "none"),
							Y.entry.classList.add("quick-input-list-separator-border");
						const se = ne.buttons;
						se && se.length
							? (Y.actionBar.push(
									se.map((re, le) =>
										(0, s.$sxc)(re, `id-${le}`, () =>
											ie.fireSeparatorButtonTriggered({
												button: re,
												separator: ie.separator,
											}),
										),
									),
									{ icon: !0, label: !1 },
								),
								Y.entry.classList.add("has-actions"))
							: Y.entry.classList.remove("has-actions"),
							this.c(ie);
					}
					disposeElement(W, X, Y) {
						this.d(W.element),
							this.isSeparatorVisible(W.element) ||
								W.element.element?.classList.remove("focus-inside"),
							super.disposeElement(W, X, Y);
					}
					c(W) {
						this.b.set(W, (this.b.get(W) || 0) + 1);
					}
					d(W) {
						const X = this.b.get(W) || 0;
						X > 1 ? this.b.set(W, X - 1) : this.b.delete(W);
					}
				}
				let q = class extends r.$1c {
					constructor(W, X, Y, ie, ne, ee) {
						super(),
							(this.M = W),
							(this.N = X),
							(this.O = Y),
							(this.P = ee),
							(this.a = new i.$re()),
							(this.onKeyDown = this.a.event),
							(this.b = new i.$re()),
							(this.onLeave = this.b.event),
							(this.c = (0, L.observableValue)("VisibleCount", 0)),
							(this.onChangedVisibleCount = i.Event.fromObservable(
								this.c,
								this.B,
							)),
							(this.f = (0, L.observableValue)("AllVisibleChecked", !1)),
							(this.onChangedAllVisibleChecked = i.Event.fromObservable(
								this.f,
								this.B,
							)),
							(this.g = (0, L.observableValue)("CheckedCount", 0)),
							(this.onChangedCheckedCount = i.Event.fromObservable(
								this.g,
								this.B,
							)),
							(this.h = (0, L.observableValueOpts)(
								{ equalsFn: D.$yb },
								new Array(),
							)),
							(this.onChangedCheckedElements = i.Event.fromObservable(
								this.h,
								this.B,
							)),
							(this.j = new i.$re()),
							(this.onButtonTriggered = this.j.event),
							(this.m = new i.$re()),
							(this.onSeparatorButtonTriggered = this.m.event),
							(this.q = new i.$re()),
							(this.r = new i.$ze()),
							(this.t = !1),
							(this.F = new Array()),
							(this.G = new Array()),
							(this.H = new Array()),
							(this.I = this.D(new r.$Zc())),
							(this.Q = !1),
							(this.R = !1),
							(this.S = !0),
							(this.U = "fuzzy"),
							(this.W = !0),
							(this.X = !0),
							(this.Y = !0),
							(this.u = t.$fhb(this.M, N(".quick-input-list"))),
							(this.z = new H(X)),
							(this.C = ne.createInstance(x, X)),
							(this.w = this.D(
								ne.createInstance(
									d.$CMb,
									"QuickInput",
									this.u,
									new U(),
									[this.C, this.z],
									{
										filter: {
											filter(_) {
												return _.hidden
													? w.TreeVisibility.Hidden
													: _ instanceof B
														? w.TreeVisibility.Recurse
														: w.TreeVisibility.Visible;
											},
										},
										sorter: {
											compare: (_, te) => {
												if (!this.sortByLabel || !this.L) return 0;
												const Q = this.L.toLowerCase();
												return K(_, te, Q);
											},
										},
										accessibilityProvider: new z(),
										setRowLineHeight: !1,
										multipleSelectionSupport: !1,
										hideTwistiesOfChildlessElements: !0,
										renderIndentGuides: I.RenderIndentGuides.None,
										findWidgetEnabled: !1,
										indent: 0,
										horizontalScrolling: !1,
										allowNonCollapsibleParents: !0,
										alwaysConsumeMouseWheel: !0,
									},
								),
							)),
							(this.w.getHTMLElement().id = ie),
							this.Z();
					}
					get onDidChangeFocus() {
						return i.Event.map(
							this.w.onDidChangeFocus,
							(W) =>
								W.elements.filter((X) => X instanceof R).map((X) => X.item),
							this.B,
						);
					}
					get onDidChangeSelection() {
						return i.Event.map(
							this.w.onDidChangeSelection,
							(W) => ({
								items: W.elements
									.filter((X) => X instanceof R)
									.map((X) => X.item),
								event: W.browserEvent,
							}),
							this.B,
						);
					}
					get displayed() {
						return this.u.style.display !== "none";
					}
					set displayed(W) {
						this.u.style.display = W ? "" : "none";
					}
					get scrollTop() {
						return this.w.scrollTop;
					}
					set scrollTop(W) {
						this.w.scrollTop = W;
					}
					get ariaLabel() {
						return this.w.ariaLabel;
					}
					set ariaLabel(W) {
						this.w.ariaLabel = W ?? "";
					}
					set enabled(W) {
						this.w.getHTMLElement().style.pointerEvents = W ? "" : "none";
					}
					get matchOnDescription() {
						return this.Q;
					}
					set matchOnDescription(W) {
						this.Q = W;
					}
					get matchOnDetail() {
						return this.R;
					}
					set matchOnDetail(W) {
						this.R = W;
					}
					get matchOnLabel() {
						return this.S;
					}
					set matchOnLabel(W) {
						this.S = W;
					}
					get matchOnLabelMode() {
						return this.U;
					}
					set matchOnLabelMode(W) {
						this.U = W;
					}
					get matchOnMeta() {
						return this.W;
					}
					set matchOnMeta(W) {
						this.W = W;
					}
					get sortByLabel() {
						return this.X;
					}
					set sortByLabel(W) {
						this.X = W;
					}
					get shouldLoop() {
						return this.Y;
					}
					set shouldLoop(W) {
						this.Y = W;
					}
					Z() {
						this.ab(),
							this.bb(),
							this.cb(),
							this.db(),
							this.eb(),
							this.fb(),
							this.gb(),
							this.ib(),
							this.hb();
					}
					ab() {
						this.D(
							this.w.onKeyDown((W) => {
								const X = new a.$7fb(W);
								switch (X.keyCode) {
									case h.KeyCode.Space:
										this.toggleCheckbox();
										break;
								}
								this.a.fire(X);
							}),
						);
					}
					bb() {
						this.D(
							t.$0fb(this.u, t.$$gb.CLICK, (W) => {
								(W.x || W.y) && this.b.fire();
							}),
						);
					}
					cb() {
						this.D(
							t.$0fb(this.u, t.$$gb.AUXCLICK, (W) => {
								W.button === 1 && this.b.fire();
							}),
						);
					}
					db() {
						this.D(
							this.w.onDidChangeModel(() => {
								const W = this.H.filter((X) => !X.hidden).length;
								this.c.set(W, void 0), this.t && this.lb();
							}),
						);
					}
					eb() {
						this.D(
							this.r.wrapEvent(this.q.event, (W, X) => X)((W) => this.lb()),
						);
					}
					fb() {
						this.D(
							this.w.onContextMenu((W) => {
								W.element &&
									(W.browserEvent.preventDefault(),
									this.w.setSelection([W.element]));
							}),
						);
					}
					gb() {
						const W = this.D(new T.$Kh(this.N.delay));
						this.D(
							this.w.onMouseOver(async (X) => {
								if (t.$Zgb(X.browserEvent.target)) {
									W.cancel();
									return;
								}
								if (
									!(
										!t.$Zgb(X.browserEvent.relatedTarget) &&
										t.$Bgb(X.browserEvent.relatedTarget, X.element?.element)
									)
								)
									try {
										await W.trigger(async () => {
											X.element instanceof R && this.mb(X.element);
										});
									} catch (Y) {
										if (!(0, P.$8)(Y)) throw Y;
									}
							}),
						),
							this.D(
								this.w.onMouseOut((X) => {
									t.$Bgb(X.browserEvent.relatedTarget, X.element?.element) ||
										W.cancel();
								}),
							);
					}
					hb() {
						this.D(
							this.w.onDidChangeFocus((W) => {
								const X = W.elements[0]
									? this.w.getParentElement(W.elements[0])
									: null;
								for (const Y of this.z.visibleSeparators) {
									const ie = Y === X;
									!!(Y.focusInsideSeparator & O.ACTIVE_ITEM) !== ie &&
										(ie
											? (Y.focusInsideSeparator |= O.ACTIVE_ITEM)
											: (Y.focusInsideSeparator &= ~O.ACTIVE_ITEM),
										this.w.rerender(Y));
								}
							}),
						),
							this.D(
								this.w.onMouseOver((W) => {
									const X = W.element
										? this.w.getParentElement(W.element)
										: null;
									for (const Y of this.z.visibleSeparators) {
										if (Y !== X) continue;
										!!(Y.focusInsideSeparator & O.MOUSE_HOVER) ||
											((Y.focusInsideSeparator |= O.MOUSE_HOVER),
											this.w.rerender(Y));
									}
								}),
							),
							this.D(
								this.w.onMouseOut((W) => {
									const X = W.element
										? this.w.getParentElement(W.element)
										: null;
									for (const Y of this.z.visibleSeparators) {
										if (Y !== X) continue;
										!!(Y.focusInsideSeparator & O.MOUSE_HOVER) &&
											((Y.focusInsideSeparator &= ~O.MOUSE_HOVER),
											this.w.rerender(Y));
									}
								}),
							);
					}
					ib() {
						this.D(
							this.w.onDidChangeSelection((W) => {
								const X = W.elements.filter((Y) => Y instanceof R);
								X.length !== W.elements.length &&
									(W.elements.length === 1 &&
										W.elements[0] instanceof B &&
										(this.w.setFocus([W.elements[0].children[0]]),
										this.w.reveal(W.elements[0], 0)),
									this.w.setSelection(X));
							}),
						);
					}
					setAllVisibleChecked(W) {
						this.r.bufferEvents(() => {
							this.H.forEach((X) => {
								!X.hidden && !X.checkboxDisabled && (X.checked = W);
							});
						});
					}
					setElements(W) {
						this.I.clear(),
							(this.L = void 0),
							(this.F = W),
							(this.t = this.M.classList.contains("show-checkboxes"));
						let X;
						(this.H = new Array()),
							(this.G = W.reduce((Y, ie, ne) => {
								let ee;
								if (ie.type === "separator") {
									if (!ie.buttons) return Y;
									(X = new B(ne, (_) => this.m.fire(_), ie)), (ee = X);
								} else {
									const _ = ne > 0 ? W[ne - 1] : void 0;
									let te;
									_ &&
										_.type === "separator" &&
										!_.buttons &&
										((X = void 0), (te = _));
									const Q = new R(
										ne,
										this.t,
										(Z) => this.j.fire(Z),
										this.q,
										ie,
										te,
									);
									if ((this.H.push(Q), X)) return X.children.push(Q), Y;
									ee = Q;
								}
								return Y.push(ee), Y;
							}, new Array())),
							this.jb(this.G),
							this.P.isScreenReaderOptimized() &&
								setTimeout(() => {
									const Y = this.w
											.getHTMLElement()
											.querySelector(".monaco-list-row.focused"),
										ie = Y?.parentNode;
									if (Y && ie) {
										const ne = Y.nextSibling;
										Y.remove(), ie.insertBefore(Y, ne);
									}
								}, 0);
					}
					setFocusedElements(W) {
						const X = W.map((Y) => this.H.find((ie) => ie.item === Y))
							.filter((Y) => !!Y)
							.filter((Y) => !Y.hidden);
						if ((this.w.setFocus(X), W.length > 0)) {
							const Y = this.w.getFocus()[0];
							Y && this.w.reveal(Y);
						}
					}
					getActiveDescendant() {
						return this.w
							.getHTMLElement()
							.getAttribute("aria-activedescendant");
					}
					setSelectedElements(W) {
						const X = W.map((Y) => this.H.find((ie) => ie.item === Y)).filter(
							(Y) => !!Y,
						);
						this.w.setSelection(X);
					}
					getCheckedElements() {
						return this.H.filter((W) => W.checked).map((W) => W.item);
					}
					setCheckedElements(W) {
						this.r.bufferEvents(() => {
							const X = new Set();
							for (const Y of W) X.add(Y);
							for (const Y of this.H) Y.checked = X.has(Y.item);
						});
					}
					focus(W) {
						if (this.H.length)
							switch (
								(W === u.QuickPickFocus.Second &&
									this.H.length < 2 &&
									(W = u.QuickPickFocus.First),
								W)
							) {
								case u.QuickPickFocus.First:
									(this.w.scrollTop = 0),
										this.w.focusFirst(void 0, (X) => X.element instanceof R);
									break;
								case u.QuickPickFocus.Second: {
									this.w.scrollTop = 0;
									let X = !1;
									this.w.focusFirst(void 0, (Y) =>
										Y.element instanceof R ? (X ? !0 : ((X = !X), !1)) : !1,
									);
									break;
								}
								case u.QuickPickFocus.Last:
									(this.w.scrollTop = this.w.scrollHeight),
										this.w.focusLast(void 0, (X) => X.element instanceof R);
									break;
								case u.QuickPickFocus.Next: {
									const X = this.w.getFocus();
									this.w.focusNext(void 0, this.Y, void 0, (ie) =>
										ie.element instanceof R
											? (this.w.reveal(ie.element), !0)
											: !1,
									);
									const Y = this.w.getFocus();
									X.length &&
										X[0] === Y[0] &&
										X[0] === this.H[this.H.length - 1] &&
										this.b.fire();
									break;
								}
								case u.QuickPickFocus.Previous: {
									const X = this.w.getFocus();
									this.w.focusPrevious(void 0, this.Y, void 0, (ie) => {
										if (!(ie.element instanceof R)) return !1;
										const ne = this.w.getParentElement(ie.element);
										return (
											ne === null || ne.children[0] !== ie.element
												? this.w.reveal(ie.element)
												: this.w.reveal(ne),
											!0
										);
									});
									const Y = this.w.getFocus();
									X.length &&
										X[0] === Y[0] &&
										X[0] === this.H[0] &&
										this.b.fire();
									break;
								}
								case u.QuickPickFocus.NextPage:
									this.w.focusNextPage(void 0, (X) =>
										X.element instanceof R
											? (this.w.reveal(X.element), !0)
											: !1,
									);
									break;
								case u.QuickPickFocus.PreviousPage:
									this.w.focusPreviousPage(void 0, (X) => {
										if (!(X.element instanceof R)) return !1;
										const Y = this.w.getParentElement(X.element);
										return (
											Y === null || Y.children[0] !== X.element
												? this.w.reveal(X.element)
												: this.w.reveal(Y),
											!0
										);
									});
									break;
								case u.QuickPickFocus.NextSeparator: {
									let X = !1;
									const Y = this.w.getFocus()[0];
									this.w.focusNext(void 0, !0, void 0, (ne) => {
										if (X) return !0;
										if (ne.element instanceof B)
											(X = !0),
												this.z.isSeparatorVisible(ne.element)
													? this.w.reveal(ne.element.children[0])
													: this.w.reveal(ne.element, 0);
										else if (ne.element instanceof R) {
											if (ne.element.separator)
												return (
													this.C.isItemWithSeparatorVisible(ne.element)
														? this.w.reveal(ne.element)
														: this.w.reveal(ne.element, 0),
													!0
												);
											if (ne.element === this.G[0])
												return this.w.reveal(ne.element, 0), !0;
										}
										return !1;
									});
									const ie = this.w.getFocus()[0];
									Y === ie &&
										((this.w.scrollTop = this.w.scrollHeight),
										this.w.focusLast(void 0, (ne) => ne.element instanceof R));
									break;
								}
								case u.QuickPickFocus.PreviousSeparator: {
									let X,
										Y = !!this.w.getFocus()[0]?.separator;
									this.w.focusPrevious(void 0, !0, void 0, (ie) => {
										if (ie.element instanceof B)
											Y
												? X ||
													(this.z.isSeparatorVisible(ie.element)
														? this.w.reveal(ie.element)
														: this.w.reveal(ie.element, 0),
													(X = ie.element.children[0]))
												: (Y = !0);
										else if (ie.element instanceof R && !X) {
											if (ie.element.separator)
												this.C.isItemWithSeparatorVisible(ie.element)
													? this.w.reveal(ie.element)
													: this.w.reveal(ie.element, 0),
													(X = ie.element);
											else if (ie.element === this.G[0])
												return this.w.reveal(ie.element, 0), !0;
										}
										return !1;
									}),
										X && this.w.setFocus([X]);
									break;
								}
							}
					}
					clearFocus() {
						this.w.setFocus([]);
					}
					domFocus() {
						this.w.domFocus();
					}
					layout(W) {
						(this.w.getHTMLElement().style.maxHeight = W
							? `${Math.floor(W / 44) * 44 + 6}px`
							: ""),
							this.w.layout();
					}
					filter(W) {
						if (((this.L = W), !(this.X || this.S || this.Q || this.R)))
							return this.w.layout(), !1;
						const X = W;
						if (
							((W = W.trim()),
							!W ||
								!(
									this.matchOnLabel ||
									this.matchOnDescription ||
									this.matchOnDetail
								))
						)
							this.H.forEach((Y) => {
								(Y.labelHighlights = void 0),
									(Y.descriptionHighlights = void 0),
									(Y.detailHighlights = void 0),
									(Y.hidden = !1);
								const ie = Y.index && this.F[Y.index - 1];
								Y.item &&
									(Y.separator =
										ie && ie.type === "separator" && !ie.buttons ? ie : void 0);
							});
						else {
							let Y;
							this.H.forEach((ie) => {
								let ne;
								this.matchOnLabelMode === "fuzzy"
									? (ne = this.matchOnLabel
											? ((0, y.$bl)(W, (0, y.$al)(ie.saneLabel)) ?? void 0)
											: void 0)
									: (ne = this.matchOnLabel
											? (V(X, (0, y.$al)(ie.saneLabel)) ?? void 0)
											: void 0);
								const ee = this.matchOnDescription
										? ((0, y.$bl)(W, (0, y.$al)(ie.saneDescription || "")) ??
											void 0)
										: void 0,
									_ = this.matchOnDetail
										? ((0, y.$bl)(W, (0, y.$al)(ie.saneDetail || "")) ?? void 0)
										: void 0;
								if (
									(ne || ee || _
										? ((ie.labelHighlights = ne),
											(ie.descriptionHighlights = ee),
											(ie.detailHighlights = _),
											(ie.hidden = !1))
										: ((ie.labelHighlights = void 0),
											(ie.descriptionHighlights = void 0),
											(ie.detailHighlights = void 0),
											(ie.hidden = ie.item ? !ie.item.alwaysShow : !0)),
									ie.item
										? (ie.separator = void 0)
										: ie.separator && (ie.hidden = !0),
									!this.sortByLabel)
								) {
									const te = (ie.index && this.F[ie.index - 1]) || void 0;
									te?.type === "separator" && !te.buttons && (Y = te),
										Y && !ie.hidden && ((ie.separator = Y), (Y = void 0));
								}
							});
						}
						return this.jb(this.X && W ? this.H : this.G), this.w.layout(), !0;
					}
					toggleCheckbox() {
						this.r.bufferEvents(() => {
							const W = this.w.getFocus().filter((Y) => Y instanceof R),
								X = this.kb(W);
							for (const Y of W) Y.checkboxDisabled || (Y.checked = !X);
						});
					}
					style(W) {
						this.w.style(W);
					}
					toggleHover() {
						const W = this.w.getFocus()[0];
						if (!W?.saneTooltip || !(W instanceof R)) return;
						if (this.J && !this.J.isDisposed) {
							this.J.dispose();
							return;
						}
						this.mb(W);
						const X = new r.$Zc();
						X.add(
							this.w.onDidChangeFocus((Y) => {
								Y.elements[0] instanceof R && this.mb(Y.elements[0]);
							}),
						),
							this.J && X.add(this.J),
							this.I.add(X);
					}
					jb(W) {
						const X = new Array();
						for (const Y of W)
							Y instanceof B
								? X.push({
										element: Y,
										collapsible: !1,
										collapsed: !1,
										children: Y.children.map((ie) => ({
											element: ie,
											collapsible: !1,
											collapsed: !1,
										})),
									})
								: X.push({ element: Y, collapsible: !1, collapsed: !1 });
						this.w.setChildren(null, X);
					}
					kb(W, X = !0) {
						for (let Y = 0, ie = W.length; Y < ie; Y++) {
							const ne = W[Y];
							if (!ne.hidden)
								if (ne.checked) X = !0;
								else return !1;
						}
						return X;
					}
					lb() {
						(0, L.transaction)((W) => {
							this.f.set(this.kb(this.H, !1), W);
							const X = this.H.filter((Y) => Y.checked).length;
							this.g.set(X, W), this.h.set(this.getCheckedElements(), W);
						});
					}
					mb(W) {
						this.J &&
							!this.J.isDisposed &&
							(this.N.onDidHideHover?.(), this.J?.dispose()),
							!(!W.element || !W.saneTooltip) &&
								(this.J = this.N.showHover(
									{
										content: W.saneTooltip,
										target: W.element,
										linkHandler: (X) => {
											this.O(X);
										},
										appearance: { showPointer: !0 },
										container: this.u,
										position: { hoverPosition: $.HoverPosition.RIGHT },
									},
									!1,
								));
					}
					getItemElement(W) {
						return this.H.find((Y) => Y.item === W)?.element;
					}
				};
				(e.$uxc = q),
					Ne([n.$ei], q.prototype, "onDidChangeFocus", null),
					Ne([n.$ei], q.prototype, "onDidChangeSelection", null),
					(e.$uxc = q = Ne([j(4, C.$Li), j(5, k.$XK)], q));
				function V(J, W) {
					const { text: X, iconOffsets: Y } = W;
					if (!Y || Y.length === 0) return G(J, X);
					const ie = (0, S.$tf)(X, " "),
						ne = X.length - ie.length,
						ee = G(J, ie);
					if (ee)
						for (const _ of ee) {
							const te = Y[_.start + ne] + ne;
							(_.start += te), (_.end += te);
						}
					return ee;
				}
				function G(J, W) {
					const X = W.toLowerCase().indexOf(J.toLowerCase());
					return X !== -1 ? [{ start: X, end: X + J.length }] : null;
				}
				function K(J, W, X) {
					const Y = J.labelHighlights || [],
						ie = W.labelHighlights || [];
					return Y.length && !ie.length
						? -1
						: !Y.length && ie.length
							? 1
							: Y.length === 0 && ie.length === 0
								? 0
								: (0, v.$bs)(J.saneSortLabel, W.saneSortLabel, X);
				}
			},
		);
	var xi =
		(this && this.__importDefault) ||
		function (ce) {
			return ce && ce.__esModule ? ce : { default: ce };
		};
	define(
		de[2867],
		he([
			1, 0, 7, 105, 183, 495, 436, 33, 6, 27, 3, 111, 28, 4, 63, 2750, 1189,
			180, 75, 5, 2866, 8, 2751, 45, 2781,
		]),
		function (
			ce,
			e,
			t,
			i,
			w,
			E,
			C,
			d,
			m,
			r,
			u,
			a,
			h,
			c,
			n,
			g,
			p,
			o,
			f,
			b,
			s,
			l,
			y,
			$,
		) {
			"use strict";
			var v;
			Object.defineProperty(e, "__esModule", { value: !0 }),
				(e.$Kxc = void 0),
				(t = mt(t)),
				(a = xi(a));
			const S = t.$;
			let I = class extends u.$1c {
				static {
					v = this;
				}
				static {
					this.a = 600;
				}
				get currentQuickInput() {
					return this.s ?? void 0;
				}
				get container() {
					return this.t;
				}
				constructor(P, k, L, D, M) {
					super(),
						(this.J = P),
						(this.L = k),
						(this.M = L),
						(this.N = D),
						(this.P = M),
						(this.j = !0),
						(this.m = this.D(new m.$re())),
						(this.n = this.D(new m.$re())),
						(this.q = this.D(new m.$re())),
						(this.r = { ctrlCmd: !1, alt: !1 }),
						(this.s = null),
						(this.w = this.D(new m.$re())),
						(this.onShow = this.w.event),
						(this.z = this.D(new m.$re())),
						(this.onHide = this.z.event),
						(this.F = p.$wxc.bindTo(this.N)),
						(this.G = p.$zxc.bindTo(this.N)),
						(this.H = p.$Bxc.bindTo(this.N)),
						(this.backButton = p.$Dxc),
						(this.b = P.idPrefix),
						(this.t = P.container),
						(this.u = P.styles),
						this.D(
							m.Event.runAndSubscribe(
								t.onDidRegisterWindow,
								({ window: N, disposables: A }) => this.Q(N, A),
								{ window: f.$Bfb, disposables: this.B },
							),
						),
						this.D(
							t.onWillUnregisterWindow((N) => {
								this.f &&
									t.getWindow(this.f.container) === N &&
									(this.X(this.L.mainContainer),
									this.layout(
										this.L.mainContainerDimension,
										this.L.mainContainerOffset.quickPickTop,
									));
							}),
						);
				}
				Q(P, k) {
					const L = (D) => {
						(this.r.ctrlCmd = D.ctrlKey || D.metaKey), (this.r.alt = D.altKey);
					};
					for (const D of [t.$$gb.KEY_DOWN, t.$$gb.KEY_UP, t.$$gb.MOUSE_DOWN])
						k.add(t.$0fb(P, D, L, !0));
				}
				S(P) {
					const k = this.W().list.getItemElement(P);
					k && (this.I = (0, y.$Jxc)(k, P, this.P));
				}
				U() {
					this.I &&
						(this.I.dispose(),
						f.$Bfb.document
							.querySelectorAll(".quick-input-preview-box")
							.forEach((k) => {
								k.parentElement && k.parentElement.removeChild(k);
							}),
						(this.I = void 0));
				}
				W(P) {
					if (this.f)
						return (
							P &&
								t.getWindow(this.t) !== t.getWindow(this.L.activeContainer) &&
								(this.X(this.L.activeContainer),
								this.layout(
									this.L.activeContainerDimension,
									this.L.activeContainerOffset.quickPickTop,
								)),
							this.f
						);
					const k = t.$fhb(this.t, S(".quick-input-widget.show-file-icons"));
					(k.tabIndex = -1), (k.style.display = "none");
					const L = t.$Rgb(k),
						D = t.$fhb(k, S(".quick-input-titlebar")),
						M = this.D(new i.$eib(D, { hoverDelegate: this.J.hoverDelegate }));
					M.domNode.classList.add("quick-input-left-action-bar");
					const N = t.$fhb(D, S(".quick-input-title")),
						A = this.D(new i.$eib(D, { hoverDelegate: this.J.hoverDelegate }));
					A.domNode.classList.add("quick-input-right-action-bar");
					const R = t.$fhb(k, S(".quick-input-header")),
						O = t.$fhb(R, S("input.quick-input-check-all"));
					(O.type = "checkbox"),
						O.setAttribute("aria-label", (0, c.localize)(2051, null)),
						this.D(
							t.$$fb(O, t.$$gb.CHANGE, (Z) => {
								const se = O.checked;
								te.setAllVisibleChecked(se);
							}),
						),
						this.D(
							t.$0fb(O, t.$$gb.CLICK, (Z) => {
								(Z.x || Z.y) && F.setFocus();
							}),
						);
					const B = t.$fhb(R, S(".quick-input-description")),
						U = t.$fhb(R, S(".quick-input-and-message")),
						z = t.$fhb(U, S(".quick-input-filter")),
						F = this.D(new g.$rxc(z, this.u.inputBox, this.u.toggle));
					F.setAttribute("aria-describedby", `${this.b}message`);
					const x = t.$fhb(z, S(".quick-input-visible-count"));
					x.setAttribute("aria-live", "polite"),
						x.setAttribute("aria-atomic", "true");
					const H = new E.$Hob(
							x,
							{ countFormat: (0, c.localize)(2052, null) },
							this.u.countBadge,
						),
						q = t.$fhb(z, S(".quick-input-count"));
					q.setAttribute("aria-live", "polite");
					const V = new E.$Hob(
							q,
							{ countFormat: (0, c.localize)(2053, null) },
							this.u.countBadge,
						),
						G = this.D(new i.$eib(R, { hoverDelegate: this.J.hoverDelegate }));
					G.domNode.classList.add("quick-input-inline-action-bar");
					const K = t.$fhb(R, S(".quick-input-action")),
						J = this.D(new w.$oob(K, this.u.button));
					(J.label = (0, c.localize)(2054, null)),
						this.D(
							J.onDidClick((Z) => {
								this.m.fire();
							}),
						);
					const W = t.$fhb(R, S(".quick-input-action")),
						X = this.D(new w.$oob(W, { ...this.u.button, supportIcons: !0 }));
					(X.label = (0, c.localize)(2055, null)),
						this.D(
							X.onDidClick((Z) => {
								this.n.fire();
							}),
						);
					const Y = t.$fhb(U, S(`#${this.b}message.quick-input-message`)),
						ie = this.D(new C.$bpb(k, this.u.progressBar));
					ie.getContainer().classList.add("quick-input-progress");
					const ne = t.$fhb(k, S(".quick-input-html-widget"));
					ne.tabIndex = -1;
					const ee = t.$fhb(k, S(".quick-input-description")),
						_ = this.b + "list",
						te = this.D(
							this.M.createInstance(
								s.$uxc,
								k,
								this.J.hoverDelegate,
								this.J.linkOpenerDelegate,
								_,
							),
						);
					F.setAttribute("aria-controls", _),
						this.D(
							te.onDidChangeFocus(() => {
								F.setAttribute(
									"aria-activedescendant",
									te.getActiveDescendant() ?? "",
								);
							}),
						),
						this.D(
							te.onChangedAllVisibleChecked((Z) => {
								O.checked = Z;
							}),
						),
						this.D(
							te.onChangedVisibleCount((Z) => {
								H.setCount(Z);
							}),
						),
						this.D(
							te.onChangedCheckedCount((Z) => {
								V.setCount(Z);
							}),
						),
						this.D(
							te.onLeave(() => {
								setTimeout(() => {
									this.s &&
										(F.setFocus(),
										this.s instanceof p.$Exc &&
											this.s.canSelectMany &&
											te.clearFocus());
								}, 0);
							}),
						);
					const Q = t.$dhb(k);
					return (
						this.D(Q),
						this.D(
							t.$0fb(
								k,
								t.$$gb.FOCUS,
								(Z) => {
									const se = this.W();
									if (t.$Bgb(Z.relatedTarget, se.inputContainer)) {
										const re = se.inputBox.isSelectionAtEnd();
										this.H.get() !== re && this.H.set(re);
									}
									t.$Bgb(Z.relatedTarget, se.container) ||
										(this.F.set(!0),
										(this.C = t.$Ygb(Z.relatedTarget)
											? Z.relatedTarget
											: void 0));
								},
								!0,
							),
						),
						this.D(
							Q.onDidBlur(() => {
								!this.W().ignoreFocusOut &&
									!this.J.ignoreFocusOut() &&
									this.hide(n.QuickInputHideReason.Blur),
									this.F.set(!1),
									this.H.set(!1),
									(this.C = void 0);
							}),
						),
						this.D(
							F.onKeyDown((Z) => {
								const se = this.W().inputBox.isSelectionAtEnd();
								this.H.get() !== se && this.H.set(se);
							}),
						),
						this.D(
							t.$0fb(k, t.$$gb.FOCUS, (Z) => {
								F.setFocus();
							}),
						),
						this.D(
							t.$$fb(k, t.$$gb.KEY_DOWN, (Z) => {
								if (!t.$Bgb(Z.target, ne))
									switch (Z.keyCode) {
										case r.KeyCode.Enter:
											t.$ahb.stop(Z, !0), this.j && this.m.fire();
											break;
										case r.KeyCode.Escape:
											t.$ahb.stop(Z, !0),
												this.hide(n.QuickInputHideReason.Gesture);
											break;
										case r.KeyCode.Tab:
											if (!Z.altKey && !Z.ctrlKey && !Z.metaKey) {
												const se = [
													".quick-input-list .monaco-action-bar .always-visible",
													".quick-input-list-entry:hover .monaco-action-bar",
													".monaco-list-row.focused .monaco-action-bar",
												];
												if (
													(k.classList.contains("show-checkboxes")
														? se.push("input")
														: se.push("input[type=text]"),
													this.W().list.displayed && se.push(".monaco-list"),
													this.W().message && se.push(".quick-input-message a"),
													this.W().widget)
												) {
													if (t.$Bgb(Z.target, this.W().widget)) break;
													se.push(".quick-input-html-widget");
												}
												const re = k.querySelectorAll(se.join(", "));
												Z.shiftKey && Z.target === re[0]
													? (t.$ahb.stop(Z, !0), te.clearFocus())
													: !Z.shiftKey &&
														t.$Bgb(Z.target, re[re.length - 1]) &&
														(t.$ahb.stop(Z, !0), re[0].focus());
											}
											break;
										case r.KeyCode.Space:
											Z.ctrlKey &&
												(t.$ahb.stop(Z, !0), this.W().list.toggleHover());
											break;
									}
							}),
						),
						(this.f = {
							container: k,
							styleSheet: L,
							leftActionBar: M,
							titleBar: D,
							title: N,
							description1: ee,
							description2: B,
							widget: ne,
							rightActionBar: A,
							inlineActionBar: G,
							checkAll: O,
							inputContainer: U,
							filterContainer: z,
							inputBox: F,
							visibleCountContainer: x,
							visibleCount: H,
							countContainer: q,
							count: V,
							okContainer: K,
							ok: J,
							message: Y,
							customButtonContainer: W,
							customButton: X,
							list: te,
							progressBar: ie,
							onDidAccept: this.m.event,
							onDidCustom: this.n.event,
							onDidTriggerButton: this.q.event,
							ignoreFocusOut: !1,
							keyMods: this.r,
							show: (Z) => this.Z(Z),
							hide: () => this.hide(),
							setVisibilities: (Z) => this.ab(Z),
							setEnabled: (Z) => this.bb(Z),
							setContextKey: (Z) => this.J.setContextKey(Z),
							linkOpenerDelegate: (Z) => this.J.linkOpenerDelegate(Z),
						}),
						this.db(),
						this.f
					);
				}
				X(P) {
					this.f && ((this.t = P), t.$fhb(this.t, this.f.container));
				}
				pick(P, k = {}, L = d.CancellationToken.None) {
					return new Promise((D, M) => {
						let N = (B) => {
							(N = D), k.onKeyMods?.(A.keyMods), D(B);
						};
						if (L.isCancellationRequested) {
							N(void 0);
							return;
						}
						const A = this.createQuickPick({ useSeparators: !0 });
						let R;
						const O = [
							A,
							A.onDidAccept(() => {
								if (A.canSelectMany) N(A.selectedItems.slice()), A.hide();
								else {
									const B = A.activeItems[0];
									B && (N(B), A.hide());
								}
							}),
							A.onDidChangeActive((B) => {
								const U = B[0];
								U && k.onDidFocus && k.onDidFocus(U);
							}),
							A.onDidChangeSelection((B) => {
								if (!A.canSelectMany) {
									const U = B[0];
									U && (N(U), A.hide());
								}
							}),
							A.onDidTriggerItemButton(
								(B) =>
									k.onDidTriggerItemButton &&
									k.onDidTriggerItemButton({
										...B,
										removeItem: () => {
											const U = A.items.indexOf(B.item);
											if (U !== -1) {
												const z = A.items.slice(),
													F = z.splice(U, 1),
													x = A.activeItems.filter((q) => q !== F[0]),
													H = A.keepScrollPosition;
												(A.keepScrollPosition = !0),
													(A.items = z),
													x && (A.activeItems = x),
													(A.keepScrollPosition = H);
											}
										},
									}),
							),
							A.onDidTriggerSeparatorButton((B) =>
								k.onDidTriggerSeparatorButton?.(B),
							),
							A.onDidChangeValue((B) => {
								R &&
									!B &&
									(A.activeItems.length !== 1 || A.activeItems[0] !== R) &&
									(A.activeItems = [R]);
							}),
							L.onCancellationRequested(() => {
								A.hide();
							}),
							A.onDidHide(() => {
								(0, u.$Vc)(O), N(void 0);
							}),
						];
						(A.title = k.title),
							k.value && (A.value = k.value),
							(A.canSelectMany = !!k.canPickMany),
							(A.placeholder = k.placeHolder),
							(A.ignoreFocusOut = !!k.ignoreFocusLost),
							(A.matchOnDescription = !!k.matchOnDescription),
							(A.matchOnDetail = !!k.matchOnDetail),
							(A.matchOnLabel = k.matchOnLabel === void 0 || k.matchOnLabel),
							(A.quickNavigate = k.quickNavigate),
							(A.hideInput = !!k.hideInput),
							(A.contextKey = k.contextKey),
							(A.busy = !0),
							Promise.all([P, k.activeItem]).then(([B, U]) => {
								(R = U),
									(A.busy = !1),
									(A.items = B),
									A.canSelectMany &&
										(A.selectedItems = B.filter(
											(z) => z.type !== "separator" && z.picked,
										)),
									R && (A.activeItems = [R]);
							}),
							A.show(),
							Promise.resolve(P).then(void 0, (B) => {
								M(B), A.hide();
							});
					});
				}
				Y(P, k) {
					k && (0, h.$lg)(k)
						? ((P.severity = a.default.Error), (P.validationMessage = k))
						: k && !(0, h.$lg)(k)
							? ((P.severity = k.severity), (P.validationMessage = k.content))
							: ((P.severity = a.default.Ignore),
								(P.validationMessage = void 0));
				}
				input(P = {}, k = d.CancellationToken.None) {
					return new Promise((L) => {
						if (k.isCancellationRequested) {
							L(void 0);
							return;
						}
						const D = this.createInputBox(),
							M = P.validateInput || (() => Promise.resolve(void 0)),
							N = m.Event.debounce(D.onDidChangeValue, (B, U) => U, 100);
						let A = P.value || "",
							R = Promise.resolve(M(A));
						const O = [
							D,
							N((B) => {
								B !== A && ((R = Promise.resolve(M(B))), (A = B)),
									R.then((U) => {
										B === A && this.Y(D, U);
									});
							}),
							D.onDidAccept(() => {
								const B = D.value;
								B !== A && ((R = Promise.resolve(M(B))), (A = B)),
									R.then((U) => {
										!U || (!(0, h.$lg)(U) && U.severity !== a.default.Error)
											? (L(B), D.hide())
											: B === A && this.Y(D, U);
									});
							}),
							k.onCancellationRequested(() => {
								D.hide();
							}),
							D.onDidHide(() => {
								(0, u.$Vc)(O), L(void 0);
							}),
						];
						(D.title = P.title),
							(D.value = P.value || ""),
							(D.valueSelection = P.valueSelection),
							(D.prompt = P.prompt),
							(D.placeholder = P.placeHolder),
							(D.password = !!P.password),
							(D.ignoreFocusOut = !!P.ignoreFocusLost),
							D.show();
					});
				}
				createQuickPick(P = { useSeparators: !1 }) {
					const k = this.W(!0),
						L = new p.$Exc(k);
					return (
						this.D(
							L.onDidChangeActive((D) => {
								this.U(), D.length > 0 && this.S(D[0]);
							}),
						),
						this.D(
							L.onDidHide(() => {
								this.U();
							}),
						),
						L
					);
				}
				createInputBox() {
					const P = this.W(!0);
					return new p.$Fxc(P);
				}
				createQuickWidget() {
					const P = this.W(!0);
					return new p.$Gxc(P);
				}
				Z(P) {
					const k = this.W(!0);
					this.w.fire();
					const L = this.s;
					(this.s = P),
						L?.didHide(),
						this.bb(!0),
						k.leftActionBar.clear(),
						(k.title.textContent = ""),
						(k.description1.textContent = ""),
						(k.description2.textContent = ""),
						t.$hhb(k.widget),
						k.rightActionBar.clear(),
						k.inlineActionBar.clear(),
						(k.checkAll.checked = !1),
						(k.inputBox.placeholder = ""),
						(k.inputBox.password = !1),
						k.inputBox.showDecoration(a.default.Ignore),
						k.visibleCount.setCount(0),
						k.count.setCount(0),
						t.$hhb(k.message),
						k.progressBar.stop(),
						k.list.setElements([]),
						(k.list.matchOnDescription = !1),
						(k.list.matchOnDetail = !1),
						(k.list.matchOnLabel = !0),
						(k.list.sortByLabel = !0),
						(k.ignoreFocusOut = !1),
						(k.inputBox.toggles = void 0);
					const D = this.J.backKeybindingLabel();
					(p.$Dxc.tooltip = D
						? (0, c.localize)(2056, null, D)
						: (0, c.localize)(2057, null)),
						(k.container.style.display = ""),
						this.cb(),
						k.inputBox.setFocus(),
						this.G.set(P.type);
				}
				isVisible() {
					return !!this.f && this.f.container.style.display !== "none";
				}
				ab(P) {
					const k = this.W();
					(k.title.style.display = P.title ? "" : "none"),
						(k.description1.style.display =
							P.description && (P.inputBox || P.checkAll) ? "" : "none"),
						(k.description2.style.display =
							P.description && !(P.inputBox || P.checkAll) ? "" : "none"),
						(k.checkAll.style.display = P.checkAll ? "" : "none"),
						(k.inputContainer.style.display = P.inputBox ? "" : "none"),
						(k.filterContainer.style.display = P.inputBox ? "" : "none"),
						(k.visibleCountContainer.style.display = P.visibleCount
							? ""
							: "none"),
						(k.countContainer.style.display = P.count ? "" : "none"),
						(k.okContainer.style.display = P.ok ? "" : "none"),
						(k.customButtonContainer.style.display = P.customButton
							? ""
							: "none"),
						(k.message.style.display = P.message ? "" : "none"),
						(k.progressBar.getContainer().style.display = P.progressBar
							? ""
							: "none"),
						(k.list.displayed = !!P.list),
						k.container.classList.toggle("show-checkboxes", !!P.checkBox),
						k.container.classList.toggle(
							"hidden-input",
							!P.inputBox && !P.description,
						),
						this.cb();
				}
				bb(P) {
					if (P !== this.j) {
						this.j = P;
						for (const k of this.W().leftActionBar.viewItems)
							k.action.enabled = P;
						for (const k of this.W().rightActionBar.viewItems)
							k.action.enabled = P;
						(this.W().checkAll.disabled = !P),
							(this.W().inputBox.enabled = P),
							(this.W().ok.enabled = P),
							(this.W().list.enabled = P);
					}
				}
				hide(P) {
					this.U();
					const k = this.s;
					if (!k) return;
					k.willHide(P);
					const L = this.f?.container,
						D = L && !t.$Lgb(L);
					if (
						((this.s = null),
						this.z.fire(),
						L && (L.style.display = "none"),
						!D)
					) {
						let M = this.C;
						for (; M && !M.offsetParent; ) M = M.parentElement ?? void 0;
						M?.offsetParent
							? (M.focus(), (this.C = void 0))
							: this.J.returnFocus();
					}
					k.didHide(P);
				}
				focus() {
					if (this.isVisible()) {
						const P = this.W();
						P.inputBox.enabled ? P.inputBox.setFocus() : P.list.domFocus();
					}
				}
				toggle() {
					this.isVisible() &&
						this.s instanceof p.$Exc &&
						this.s.canSelectMany &&
						this.W().list.toggleCheckbox();
				}
				navigate(P, k) {
					this.isVisible() &&
						this.W().list.displayed &&
						(this.W().list.focus(
							P ? n.QuickPickFocus.Next : n.QuickPickFocus.Previous,
						),
						k && this.s instanceof p.$Exc && (this.s.quickNavigate = k));
				}
				async accept(P = { alt: !1, ctrlCmd: !1 }) {
					(this.r.alt = P.alt), (this.r.ctrlCmd = P.ctrlCmd), this.m.fire();
				}
				async back() {
					this.q.fire(this.backButton);
				}
				async cancel() {
					this.hide();
				}
				layout(P, k) {
					(this.g = P), (this.h = k), this.cb();
				}
				cb() {
					if (this.f && this.isVisible()) {
						this.f.container.style.top = `${this.h}px`;
						const P = this.f.container.style,
							k = Math.min(this.g.width * 0.62, v.a);
						(P.width = k + "px"),
							(P.marginLeft = "-" + k / 2 + "px"),
							this.f.inputBox.layout(),
							this.f.list.layout(this.g && this.g.height * 0.4);
					}
				}
				applyStyles(P) {
					(this.u = P), this.db();
				}
				db() {
					if (this.f) {
						const {
							quickInputTitleBackground: P,
							quickInputBackground: k,
							quickInputForeground: L,
							widgetBorder: D,
							widgetShadow: M,
						} = this.u.widget;
						(this.f.titleBar.style.backgroundColor = P ?? ""),
							(this.f.container.style.backgroundColor = k ?? ""),
							(this.f.container.style.color = L ?? ""),
							(this.f.container.style.border = D ? `1px solid ${D}` : ""),
							(this.f.container.style.boxShadow = M ? `0 0 8px 2px ${M}` : ""),
							this.f.list.style(this.u.list);
						const N = [];
						this.u.pickerGroup.pickerGroupBorder &&
							N.push(
								`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.u.pickerGroup.pickerGroupBorder}; }`,
							),
							this.u.pickerGroup.pickerGroupForeground &&
								N.push(
									`.quick-input-list .quick-input-list-separator { color:  ${this.u.pickerGroup.pickerGroupForeground}; }`,
								),
							this.u.pickerGroup.pickerGroupForeground &&
								N.push(
									".quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }",
								),
							(this.u.keybindingLabel.keybindingLabelBackground ||
								this.u.keybindingLabel.keybindingLabelBorder ||
								this.u.keybindingLabel.keybindingLabelBottomBorder ||
								this.u.keybindingLabel.keybindingLabelShadow ||
								this.u.keybindingLabel.keybindingLabelForeground) &&
								(N.push(
									".quick-input-list .monaco-keybinding > .monaco-keybinding-key {",
								),
								this.u.keybindingLabel.keybindingLabelBackground &&
									N.push(
										`background-color: ${this.u.keybindingLabel.keybindingLabelBackground};`,
									),
								this.u.keybindingLabel.keybindingLabelBorder &&
									N.push(
										`border-color: ${this.u.keybindingLabel.keybindingLabelBorder};`,
									),
								this.u.keybindingLabel.keybindingLabelBottomBorder &&
									N.push(
										`border-bottom-color: ${this.u.keybindingLabel.keybindingLabelBottomBorder};`,
									),
								this.u.keybindingLabel.keybindingLabelShadow &&
									N.push(
										`box-shadow: inset 0 -1px 0 ${this.u.keybindingLabel.keybindingLabelShadow};`,
									),
								this.u.keybindingLabel.keybindingLabelForeground &&
									N.push(
										`color: ${this.u.keybindingLabel.keybindingLabelForeground};`,
									),
								N.push("}"));
						const A = N.join(`
`);
						A !== this.f.styleSheet.textContent &&
							(this.f.styleSheet.textContent = A);
					}
				}
			};
			(e.$Kxc = I),
				(e.$Kxc =
					I =
					v =
						Ne([j(1, o.$jEb), j(2, b.$Li), j(3, l.$6j), j(4, $.$0zb)], I));
		},
	),
		define(
			de[2868],
			he([
				1, 0, 33, 6, 8, 5, 180, 41, 1636, 106, 51, 35, 1189, 2867, 31, 58, 10,
				7,
			]),
			function (ce, e, t, i, w, E, C, d, m, r, u, a, h, c, n, g, p, o) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$Lxc = void 0);
				let f = class extends a.$pP {
					get backButton() {
						return this.f.backButton;
					}
					get f() {
						return this.c || (this.c = this.D(this.z())), this.c;
					}
					get g() {
						return !!this.c;
					}
					get currentQuickInput() {
						return this.f.currentQuickInput;
					}
					get quickAccess() {
						return (
							this.j || (this.j = this.D(this.r.createInstance(m.$T9b))), this.j
						);
					}
					constructor(s, l, y, $, v, S) {
						super(y),
							(this.r = s),
							(this.s = l),
							(this.t = $),
							(this.u = v),
							(this.y = S),
							(this.a = this.D(new i.$re())),
							(this.onShow = this.a.event),
							(this.b = this.D(new i.$re())),
							(this.onHide = this.b.event),
							(this.m = new Map());
					}
					z(s = this.t, l) {
						const y = {
								idPrefix: "quickInput_",
								container: s.activeContainer,
								ignoreFocusOut: () => !1,
								backKeybindingLabel: () => {},
								setContextKey: (v) => this.C(v),
								linkOpenerDelegate: (v) => {
									this.r.invokeFunction((S) => {
										S.get(d.$7rb).open(v, {
											allowCommands: !0,
											fromUserGesture: !0,
										});
									});
								},
								returnFocus: () => s.focus(),
								styles: this.G(),
								hoverDelegate: this.D(this.r.createInstance(h.$Hxc)),
							},
							$ = this.D(this.r.createInstance(c.$Kxc, { ...y, ...l }));
						return (
							$.layout(
								s.activeContainerDimension,
								s.activeContainerOffset.quickPickTop,
							),
							this.D(
								s.onDidLayoutActiveContainer((v) => {
									(0, o.getWindow)(s.activeContainer) ===
										(0, o.getWindow)($.container) &&
										$.layout(v, s.activeContainerOffset.quickPickTop);
								}),
							),
							this.D(
								s.onDidChangeActiveContainer(() => {
									$.isVisible() ||
										$.layout(
											s.activeContainerDimension,
											s.activeContainerOffset.quickPickTop,
										);
								}),
							),
							this.D(
								$.onShow(() => {
									this.F(), this.a.fire();
								}),
							),
							this.D(
								$.onHide(() => {
									this.F(), this.b.fire();
								}),
							),
							$
						);
					}
					C(s) {
						let l;
						s &&
							((l = this.m.get(s)),
							l || ((l = new w.$5j(s, !1).bindTo(this.s)), this.m.set(s, l))),
							!(l && l.get()) && (this.F(), l?.set(!0));
					}
					F() {
						this.m.forEach((s) => {
							s.get() && s.reset();
						});
					}
					pick(s, l, y = t.CancellationToken.None) {
						return this.f.pick(s, l, y);
					}
					input(s = {}, l = t.CancellationToken.None) {
						if (s.prompt?.startsWith(g.$vX) === !0) {
							const y = s.prompt.slice(g.$vX.length);
							return new Promise(($) => {
								if (l.isCancellationRequested) {
									$(void 0);
									return;
								}
								this.y
									.executeCommand(g.$sX, y)
									.then((v) => {
										$(v);
									})
									.catch((v) => {
										console.error(v), $(void 0);
									});
							});
						}
						return this.f.input(s, l);
					}
					createQuickPick(s = { useSeparators: !1 }) {
						return this.f.createQuickPick(s);
					}
					createInputBox() {
						return this.f.createInputBox();
					}
					createQuickWidget() {
						return this.f.createQuickWidget();
					}
					focus() {
						this.f.focus();
					}
					toggle() {
						this.f.toggle();
					}
					navigate(s, l) {
						this.f.navigate(s, l);
					}
					accept(s) {
						return this.f.accept(s);
					}
					back() {
						return this.f.back();
					}
					cancel() {
						return this.f.cancel();
					}
					updateStyles() {
						this.g && this.f.applyStyles(this.G());
					}
					G() {
						return {
							widget: {
								quickInputBackground: (0, u.$rP)(u.$fT),
								quickInputForeground: (0, u.$rP)(u.$gT),
								quickInputTitleBackground: (0, u.$rP)(u.$hT),
								widgetBorder: (0, u.$rP)(u.$cR),
								widgetShadow: (0, u.$rP)(u.$bR),
							},
							inputBox: r.$wyb,
							toggle: r.$pyb,
							countBadge: r.$zyb,
							button: r.$lyb,
							progressBar: r.$nyb,
							keybindingLabel: r.$jyb,
							list: (0, r.$Eyb)({
								listBackground: u.$fT,
								listFocusBackground: u.$nT,
								listFocusForeground: u.$lT,
								listInactiveFocusForeground: u.$lT,
								listInactiveSelectionIconForeground: u.$mT,
								listInactiveFocusBackground: u.$nT,
								listFocusOutline: u.$PP,
								listInactiveFocusOutline: u.$PP,
							}),
							pickerGroup: {
								pickerGroupBorder: (0, u.$rP)(u.$jT),
								pickerGroupForeground: (0, u.$rP)(u.$iT),
							},
						};
					}
				};
				(e.$Lxc = f),
					(e.$Lxc = f =
						Ne(
							[
								j(0, E.$Li),
								j(1, w.$6j),
								j(2, a.$iP),
								j(3, C.$jEb),
								j(4, p.$gj),
								j(5, n.$ek),
							],
							f,
						));
			},
		),
		define(
			de[778],
			he([1, 0, 15, 97, 6, 4, 250, 30]),
			function (ce, e, t, i, w, E, C, d) {
				"use strict";
				Object.defineProperty(e, "__esModule", { value: !0 }),
					(e.$omc = e.SemanticTokenRule = e.$lmc = e.$kmc = void 0),
					(e.$mmc = s),
					(e.$nmc = $),
					(E = mt(E)),
					(d = mt(d));
				const m = "*",
					r = ":",
					u = ".",
					a = "\\w+[-_\\w+]*";
				e.$kmc = `^${a}$`;
				const h = `^(${a}|\\*)(\\${u}${a})*(${r}${a})?$`,
					c = "^(\\s*(italic|bold|underline|strikethrough))*\\s*$";
				class n {
					constructor(P, k, L, D, M) {
						(this.foreground = P),
							(this.bold = k),
							(this.underline = L),
							(this.strikethrough = D),
							(this.italic = M);
					}
				}
				(e.$lmc = n),
					(function (T) {
						function P(A) {
							return {
								_foreground:
									A.foreground === void 0
										? null
										: i.$UL.Format.CSS.formatHexA(A.foreground, !0),
								_bold: A.bold === void 0 ? null : A.bold,
								_underline: A.underline === void 0 ? null : A.underline,
								_italic: A.italic === void 0 ? null : A.italic,
								_strikethrough:
									A.strikethrough === void 0 ? null : A.strikethrough,
							};
						}
						T.toJSONObject = P;
						function k(A) {
							if (A) {
								const R = (B) => (typeof B == "boolean" ? B : void 0),
									O = (B) => (typeof B == "string" ? i.$UL.fromHex(B) : void 0);
								return new T(
									O(A._foreground),
									R(A._bold),
									R(A._underline),
									R(A._strikethrough),
									R(A._italic),
								);
							}
						}
						T.fromJSONObject = k;
						function L(A, R) {
							return A === R
								? !0
								: A !== void 0 &&
										R !== void 0 &&
										(A.foreground instanceof i.$UL
											? A.foreground.equals(R.foreground)
											: R.foreground === void 0) &&
										A.bold === R.bold &&
										A.underline === R.underline &&
										A.strikethrough === R.strikethrough &&
										A.italic === R.italic;
						}
						T.equals = L;
						function D(A) {
							return A instanceof T;
						}
						T.is = D;
						function M(A) {
							return new T(
								A.foreground,
								A.bold,
								A.underline,
								A.strikethrough,
								A.italic,
							);
						}
						T.fromData = M;
						function N(A, R, O, B, U, z) {
							let F;
							if ((A !== void 0 && (F = i.$UL.fromHex(A)), R !== void 0)) {
								O = z = B = U = !1;
								const x = /italic|bold|underline|strikethrough/g;
								let H;
								for (; (H = x.exec(R)); )
									switch (H[0]) {
										case "bold":
											O = !0;
											break;
										case "italic":
											z = !0;
											break;
										case "underline":
											B = !0;
											break;
										case "strikethrough":
											U = !0;
											break;
									}
							}
							return new T(F, O, B, U, z);
						}
						T.fromSettings = N;
					})(n || (e.$lmc = n = {}));
				var g;
				(function (T) {
					function P(M, N) {
						if (N && typeof N._selector == "string" && N._style) {
							const A = n.fromJSONObject(N._style);
							if (A)
								try {
									return {
										selector: M.parseTokenSelector(N._selector),
										style: A,
									};
								} catch {}
						}
					}
					T.fromJSONObject = P;
					function k(M) {
						return {
							_selector: M.selector.id,
							_style: n.toJSONObject(M.style),
						};
					}
					T.toJSONObject = k;
					function L(M, N) {
						return M === N
							? !0
							: M !== void 0 &&
									N !== void 0 &&
									M.selector &&
									N.selector &&
									M.selector.id === N.selector.id &&
									n.equals(M.style, N.style);
					}
					T.equals = L;
					function D(M) {
						return (
							M &&
							M.selector &&
							typeof M.selector.id == "string" &&
							n.is(M.style)
						);
					}
					T.is = D;
				})(g || (e.SemanticTokenRule = g = {}));
				const p = {
					TokenClassificationContribution:
						"base.contributions.tokenClassification",
				};
				class o {
					constructor() {
						(this.c = new w.$re()),
							(this.onDidChangeSchema = this.c.event),
							(this.d = 0),
							(this.f = 1),
							(this.j = []),
							(this.m = {
								type: "object",
								properties: {},
								patternProperties: { [h]: v() },
								additionalProperties: !1,
								definitions: {
									style: {
										type: "object",
										description: E.localize(2373, null),
										properties: {
											foreground: {
												type: "string",
												description: E.localize(2374, null),
												format: "color-hex",
												default: "#ff0000",
											},
											background: {
												type: "string",
												deprecationMessage: E.localize(2375, null),
											},
											fontStyle: {
												type: "string",
												description: E.localize(2376, null),
												pattern: c,
												patternErrorMessage: E.localize(2377, null),
												defaultSnippets: [
													{ label: E.localize(2378, null), bodyText: '""' },
													{ body: "italic" },
													{ body: "bold" },
													{ body: "underline" },
													{ body: "strikethrough" },
													{ body: "italic bold" },
													{ body: "italic underline" },
													{ body: "italic strikethrough" },
													{ body: "bold underline" },
													{ body: "bold strikethrough" },
													{ body: "underline strikethrough" },
													{ body: "italic bold underline" },
													{ body: "italic bold strikethrough" },
													{ body: "italic underline strikethrough" },
													{ body: "bold underline strikethrough" },
													{ body: "italic bold underline strikethrough" },
												],
											},
											bold: {
												type: "boolean",
												description: E.localize(2379, null),
											},
											italic: {
												type: "boolean",
												description: E.localize(2380, null),
											},
											underline: {
												type: "boolean",
												description: E.localize(2381, null),
											},
											strikethrough: {
												type: "boolean",
												description: E.localize(2382, null),
											},
										},
										defaultSnippets: [
											{
												body: {
													foreground: "${1:#FF0000}",
													fontStyle: "${2:bold}",
												},
											},
										],
									},
								},
							}),
							(this.g = Object.create(null)),
							(this.h = Object.create(null)),
							(this.l = Object.create(null));
					}
					registerTokenType(P, k, L, D) {
						if (!P.match(e.$kmc)) throw new Error("Invalid token type id.");
						if (L && !L.match(e.$kmc))
							throw new Error("Invalid token super type id.");
						const N = {
							num: this.d++,
							id: P,
							superType: L,
							description: k,
							deprecationMessage: D,
						};
						this.g[P] = N;
						const A = v(k, D);
						(this.m.properties[P] = A), (this.l = Object.create(null));
					}
					registerTokenModifier(P, k, L) {
						if (!P.match(e.$kmc)) throw new Error("Invalid token modifier id.");
						const D = this.f;
						this.f = this.f * 2;
						const M = { num: D, id: P, description: k, deprecationMessage: L };
						(this.h[P] = M), (this.m.properties[`*.${P}`] = v(k, L));
					}
					parseTokenSelector(P, k) {
						const L = s(P, k);
						return L.type
							? {
									match: (D, M, N) => {
										let A = 0;
										if (L.language !== void 0) {
											if (L.language !== N) return -1;
											A += 10;
										}
										if (L.type !== m) {
											const O = this.n(D).indexOf(L.type);
											if (O === -1) return -1;
											A += 100 - O;
										}
										for (const R of L.modifiers)
											if (M.indexOf(R) === -1) return -1;
										return A + L.modifiers.length * 100;
									},
									id: `${[L.type, ...L.modifiers.sort()].join(".")}${L.language !== void 0 ? ":" + L.language : ""}`,
								}
							: { match: () => -1, id: "$invalid" };
					}
					registerTokenStyleDefault(P, k) {
						this.j.push({ selector: P, defaults: k });
					}
					deregisterTokenStyleDefault(P) {
						const k = P.id;
						this.j = this.j.filter((L) => L.selector.id !== k);
					}
					deregisterTokenType(P) {
						delete this.g[P],
							delete this.m.properties[P],
							(this.l = Object.create(null));
					}
					deregisterTokenModifier(P) {
						delete this.h[P], delete this.m.properties[`*.${P}`];
					}
					getTokenTypes() {
						return Object.keys(this.g).map((P) => this.g[P]);
					}
					getTokenModifiers() {
						return Object.keys(this.h).map((P) => this.h[P]);
					}
					getTokenStylingSchema() {
						return this.m;
					}
					getTokenStylingDefaultRules() {
						return this.j;
					}
					n(P) {
						let k = this.l[P];
						if (!k) {
							this.l[P] = k = [P];
							let L = this.g[P];
							for (; L && L.superType; )
								k.push(L.superType), (L = this.g[L.superType]);
						}
						return k;
					}
					toString() {
						const P = (k, L) => {
							const D = k.indexOf(".") === -1 ? 0 : 1,
								M = L.indexOf(".") === -1 ? 0 : 1;
							return D !== M ? D - M : k.localeCompare(L);
						};
						return Object.keys(this.g)
							.sort(P)
							.map((k) => `- \`${k}\`: ${this.g[k].description}`)
							.join(`
`);
					}
				}
				const f = r.charCodeAt(0),
					b = u.charCodeAt(0);
				function s(T, P) {
					let k = T.length,
						L = P;
					const D = [];
					for (let N = k - 1; N >= 0; N--) {
						const A = T.charCodeAt(N);
						if (A === f || A === b) {
							const R = T.substring(N + 1, k);
							(k = N), A === f ? (L = R) : D.push(R);
						}
					}
					return { type: T.substring(0, k), modifiers: D, language: L };
				}
				const l = y();
				d.$Io.add(p.TokenClassificationContribution, l);
				function y() {
					const T = new o();
					function P(L, D, M = [], N, A) {
						return T.registerTokenType(L, D, N, A), M && k(L, M), L;
					}
					function k(L, D) {
						try {
							const M = T.parseTokenSelector(L);
							T.registerTokenStyleDefault(M, { scopesToProbe: D });
						} catch (M) {
							console.log(M);
						}
					}
					return (
						P("comment", E.localize(2383, null), [["comment"]]),
						P("string", E.localize(2384, null), [["string"]]),
						P("keyword", E.localize(2385, null), [["keyword.control"]]),
						P("number", E.localize(2386, null), [["constant.numeric"]]),
						P("regexp", E.localize(2387, null), [["constant.regexp"]]),
						P("operator", E.localize(2388, null), [["keyword.operator"]]),
						P("namespace", E.localize(2389, null), [["entity.name.namespace"]]),
						P("type", E.localize(2390, null), [
							["entity.name.type"],
							["support.type"],
						]),
						P("struct", E.localize(2391, null), [["entity.name.type.struct"]]),
						P("class", E.localize(2392, null), [
							["entity.name.type.class"],
							["support.class"],
						]),
						P("interface", E.localize(2393, null), [
							["entity.name.type.interface"],
						]),
						P("enum", E.localize(2394, null), [["entity.name.type.enum"]]),
						P("typeParameter", E.localize(2395, null), [
							["entity.name.type.parameter"],
						]),
						P("function", E.localize(2396, null), [
							["entity.name.function"],
							["support.function"],
						]),
						P(
							"member",
							E.localize(2397, null),
							[],
							"method",
							"Deprecated use `method` instead",
						),
						P("method", E.localize(2398, null), [
							["entity.name.function.member"],
							["support.function"],
						]),
						P("macro", E.localize(2399, null), [
							["entity.name.function.preprocessor"],
						]),
						P("variable", E.localize(2400, null), [
							["variable.other.readwrite"],
							["entity.name.variable"],
						]),
						P("parameter", E.localize(2401, null), [["variable.parameter"]]),
						P("property", E.localize(2402, null), [
							["variable.other.property"],
						]),
						P("enumMember", E.localize(2403, null), [
							["variable.other.enummember"],
						]),
						P("event", E.localize(2404, null), [["variable.other.event"]]),
						P("decorator", E.localize(2405, null), [
							["entity.name.decorator"],
							["entity.name.function"],
						]),
						P("label", E.localize(2406, null), void 0),
						T.registerTokenModifier(
							"declaration",
							E.localize(2407, null),
							void 0,
						),
						T.registerTokenModifier(
							"documentation",
							E.localize(2408, null),
							void 0,
						),
						T.registerTokenModifier("static", E.localize(2409, null), void 0),
						T.registerTokenModifier("abstract", E.localize(2410, null), void 0),
						T.registerTokenModifier(
							"deprecated",
							E.localize(2411, null),
							void 0,
						),
						T.registerTokenModifier(
							"modification",
							E.localize(2412, null),
							void 0,
						),
						T.registerTokenModifier("async", E.localize(2413, null), void 0),
						T.registerTokenModifier("readonly", E.localize(2414, null), void 0),
						k("variable.readonly", [["variable.other.constant"]]),
						k("property.readonly", [["variable.other.constant.property"]]),
						k("type.defaultLibrary", [["support.type"]]),
						k("class.defaultLibrary", [["support.class"]]),
						k("interface.defaultLibrary", [["support.class"]]),
						k("variable.defaultLibrary", [
							["support.variable"],
							["support.other.variable"],
						]),
						k("variable.defaultLibrary.readonly", [["support.constant"]]),
						k("property.defaultLibrary", [["support.variable.property"]]),
						k("property.defaultLibrary.readonly", [
							["support.constant.property"],
						]),
						k("function.defaultLibrary", [["support.function"]]),
						k("member.defaultLibrary", [["support.function"]]),
						T
					);
				}
				function $() {
					return l;
				}
				function v(T, P) {
					return {
						description: T,
						deprecationMessage: P,
						defaultSnippets: [{ body: "${1:#ff0000}" }],
						anyOf: [
							{ type: "string", format: "color-hex" },
							{ $ref: "#/definitions/style" },
						],
					};
				}
				e.$omc = "vscode://schemas/token-styling";
				const S = d.$Io.as(C.$Jo.JSONContribution);
				S.registerSchema(e.$omc, l.getTokenStylingSchema());
				const I = new t.$Yh(() => S.notifySchemaChanged(e.$omc), 200);
				l.onDidChangeSchema(() => {
					I.isScheduled() || I.schedule();
				});
			},
		),
		